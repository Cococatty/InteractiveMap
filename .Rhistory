#******************************************************************
# allocate matrix to store backtest results
dummy = matrix('', len(vol.lens), len(mom.lens))
colnames(dummy) = paste('M', mom.lens)
rownames(dummy) = paste('V', vol.lens)
names = spl('Sharpe,Cagr,DVR,MaxDD')
layout(matrix(1:4,nrow=2))
for(i in names) {
dummy[] = ''
for(n.mom in mom.lens)
for(n.vol in vol.lens)
dummy[paste('V', n.vol), paste('M', n.mom)] =
out[i, paste('M', n.mom, 'V', n.vol) ]
plot.table(dummy, smain = i, highlight = T, colorbar = F)
}
mrownames = spl('row one,row two,row 3')
mcolnames = spl('col 1,col 2,col 3,col 4')
# create temp matrix with data you want to plot
temp = matrix(NA, len(mrownames), len(mcolnames))
rownames(temp) = mrownames
colnames(temp) = mcolnames
temp[,] = matrix(1:12,3,4)
# plot temp, display current date in (top, left) cell
plot.table(temp, format(as.Date(Sys.time()), '%d %b %Y'))
temp = matrix(NA, len(mrownames), len(mcolnames))
temp
mcolnames
temp
# load Systematic Investor Toolbox
setInternet2(TRUE)
source(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))
require('quantmod') || install.packages('quantmod')
# define row and column titles
mrownames = spl('row one,row two,row 3')
mcolnames = spl('col 1,col 2,col 3,col 4')
# create temp matrix with data you want to plot
temp = matrix(NA, len(mrownames), len(mcolnames))
rownames(temp) = mrownames
colnames(temp) = mcolnames
temp[,] = matrix(1:12,3,4)
temp
con
rm(list=ls())
###############################################################################
# Load Systematic Investor Toolbox (SIT)
# http://systematicinvestor.wordpress.com/systematic-investor-toolbox/
###############################################################################
setInternet2(TRUE)
con = gzcon(url('http://www.systematicportfolio.com/sit.gz', 'rb'))
source(con)
close(con)
con
rm(list=ls())
# load Systematic Investor Toolbox
setInternet2(TRUE)
source(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))
require('quantmod') || install.packages('quantmod')
# define row and column titles
mrownames = spl('row one,row two,row 3')
mcolnames = spl('col 1,col 2,col 3,col 4')
# create temp matrix with data you want to plot
temp = matrix(NA, len(mrownames), len(mcolnames))
rownames(temp) = mrownames
colnames(temp) = mcolnames
temp[,] = matrix(1:12,3,4)
# plot temp, display current date in (top, left) cell
plot.table(temp, format(as.Date(Sys.time()), '%d %b %Y'))
# generate 1,000 random numbers from Normal(0,1) distribution
data =  matrix(rnorm(1000), nc=10)
colnames(data) = paste('data', 1:10, sep='')
# compute Pearson correlation of data and format it nicely
temp = compute.cor(data, 'pearson')
temp[] = plota.format(100 * temp, 0, '', '%')
# plot temp with colorbar, display Correlation in (top, left) cell
plot.table(temp, smain='Correlation', highlight = TRUE, colorbar = TRUE)
rm(list=ls())
# load Systematic Investor Toolbox
setInternet2(TRUE)
source(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))
require('quantmod') || install.packages('quantmod')
# define row and column titles
mrownames = spl('row one,row two,row 3')
mcolnames = spl('col 1,col 2,col 3,col 4')
# create temp matrix with data you want to plot
temp = matrix(NA, len(mrownames), len(mcolnames))
rownames(temp) = mrownames
colnames(temp) = mcolnames
temp[,] = matrix(1:12,3,4)
###############################################################################
# Load Systematic Investor Toolbox (SIT)
# http://systematicinvestor.wordpress.com/systematic-investor-toolbox/
###############################################################################
setInternet2(TRUE)
con = gzcon(url('http://www.systematicportfolio.com/sit.gz', 'rb'))
source(con)
close(con)
load.packages('quantmod')
tickers = spl('SPY,EFA,EWJ,EEM,IYR,RWX,IEF,TLT,DBC,GLD')
data <- new.env()
data
getSymbols(tickers, src = 'yahoo', from = '1980-01-01', env = data, auto.assign = T)
for(i in ls(data)) data[[i]] = adjustOHLC(data[[i]], use.Adjusted=T)
bt.prep(data, align='keep.all', dates='2004:12::')
prices = data$prices
n = ncol(prices)
prices
n
models = list()
models
# find period ends
period.ends = endpoints(prices, 'months')
period.ends = period.ends[period.ends > 0]
period.ends
models = list()
models$combo = bt.aaa.combo(data, period.ends, n.top = 5,
n.mom = 180, n.vol = 20)
models$aaa = bt.aaa.minrisk(data, period.ends, n.top = 5,
n.mom = 180, n.vol = 20)
plotbt.custom.report.part1(models)
mom.lens = ( 1 : 12 ) * 20
# length of volatility look back
vol.lens = ( 1 : 12 ) * 20
models = list()
# evaluate strategies
for(n.mom in mom.lens) {
cat('MOM =', n.mom, '\n')
for(n.vol in vol.lens) {
cat('\tVOL =', n.vol, '\n')
models[[ paste('M', n.mom, 'V', n.vol) ]] =
bt.aaa.combo(data, period.ends, n.top = 5,
n.mom = n.mom, n.vol = n.vol)
}
}
out = plotbt.strategy.sidebyside(models, return.table=T, make.plot = F)
vol.lens
dummy = matrix('', len(vol.lens), len(mom.lens))
dummy
colnames(dummy) = paste('M', mom.lens)
dummy
colnames(dummy) = paste('M', mom.lens)
rownames(dummy) = paste('V', vol.lens)
names = spl('Sharpe,Cagr,DVR,MaxDD')
layout(matrix(1:4,nrow=2))
dummy
names
layout(matrix(1:4,nrow=2))
for(i in names) {
dummy[] = ''
for(n.mom in mom.lens)
for(n.vol in vol.lens)
dummy[paste('V', n.vol), paste('M', n.mom)] =
out[i, paste('M', n.mom, 'V', n.vol) ]
plot.table(dummy, smain = i, highlight = T, colorbar = T)
}
rm(list=ls())
# load Systematic Investor Toolbox
setInternet2(TRUE)
source(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))
require('quantmod') || install.packages('quantmod')
# define row and column titles
mrownames = spl('row one,row two,row 3')
mcolnames = spl('col 1,col 2,col 3,col 4')
# create temp matrix with data you want to plot
temp = matrix(NA, len(mrownames), len(mcolnames))
rownames(temp) = mrownames
colnames(temp) = mcolnames
temp[,] = matrix(1:12,3,4)
# plot temp, display current date in (top, left) cell
plot.table(temp, format(as.Date(Sys.time()), '%d %b %Y'))
# generate 1,000 random numbers from Normal(0,1) distribution
data =  matrix(rnorm(1000), nc=10)
colnames(data) = paste('data', 1:10, sep='')
# compute Pearson correlation of data and format it nicely
temp = compute.cor(data, 'pearson')
temp[] = plota.format(100 * temp, 0, '', '%')
# plot temp with colorbar, display Correlation in (top, left) cell
plot.table(temp, smain='Correlation', highlight = TRUE, colorbar = TRUE)
###############################################################################
# Load Systematic Investor Toolbox (SIT)
# http://systematicinvestor.wordpress.com/systematic-investor-toolbox/
###############################################################################
setInternet2(TRUE)
con = gzcon(url('http://www.systematicportfolio.com/sit.gz', 'rb'))
source(con)
close(con)
#*****************************************************************
# Load historical data
#******************************************************************
load.packages('quantmod')
# load Systematic Investor Toolbox
setInternet2(TRUE)
source(gzcon(url('https://github.com/systematicinvestor/SIT/raw/master/sit.gz', 'rb')))
require('quantmod') || install.packages('quantmod')
# define row and column titles
mrownames = spl('row one,row two,row 3')
mcolnames = spl('col 1,col 2,col 3,col 4')
# create temp matrix with data you want to plot
temp = matrix(NA, len(mrownames), len(mcolnames))
rownames(temp) = mrownames
colnames(temp) = mcolnames
temp[,] = matrix(1:12,3,4)
# plot temp, display current date in (top, left) cell
plot.table(temp, format(as.Date(Sys.time()), '%d %b %Y'))
# generate 1,000 random numbers from Normal(0,1) distribution
data =  matrix(rnorm(1000), nc=10)
colnames(data) = paste('data', 1:10, sep='')
# compute Pearson correlation of data and format it nicely
temp = compute.cor(data, 'pearson')
temp[] = plota.format(100 * temp, 0, '', '%')
# plot temp with colorbar, display Correlation in (top, left) cell
plot.table(temp, smain='Correlation', highlight = TRUE, colorbar = TRUE)
data
temp
temp = compute.cor(data, 'pearson')
temp
temp[] = plota.format(100 * temp, 0, '', '%')
temp
temp
#Some sample data
x <- runif(100)
dat <- data.frame(x = x,y = x^2 + 1)
dat
#Create a function to generate a continuous color palette
rbPal <- colorRampPalette(c('red','blue'))
#This adds a column of color values
# based on the y values
dat$Col <- rbPal(10)[as.numeric(cut(dat$y,breaks = 10))]
head(dat)
cut(dat$y,breaks = 10)
as.numeric(cut(dat$y,breaks = 10))
plot(dat$x,dat$y,pch = 20,col = dat$Col)
Z <- stats::rnorm(10000)
table(cut(Z, breaks = -6:6))
Z
table(cut(Z, breaks = -6:6))
example(persp3D)
example(surf3D)
require("plot3D")
example(persp3D)
example(mesh)
example(perspbox)
example(jet.col)
example(jet.col)
example(image3D)
example(image2D)
example(segments3D)
example(scatter3D)
example(persp3D)
example(surf3D)
example(slice3D)
x <- c(1:9, 8:1)
y <- c(1, 2*(5:3), 2, -1, 17, 9, 8, 2:9)
op <- par(mfcol = c(3, 1))
for(xpd in c(FALSE, TRUE, NA)) {
plot(1:10, main = paste("xpd =", xpd))
box("figure", col = "pink", lwd = 3)
polygon(x, y, xpd = xpd, col = "orange", lty = 2, lwd = 2, border = "red")
}
n <- 100
xx <- c(0:n, n:0)
yy <- c(c(0, cumsum(stats::rnorm(n))), rev(c(0, cumsum(stats::rnorm(n)))))
plot   (xx, yy, type = "n", xlab = "Time", ylab = "Distance")
title("Distance Between Brownian Motions")
# Multiple polygons from NA values
# and recycling of col, border, and lty
op <- par(mfrow = c(2, 1))
plot(c(1, 9), 1:2, type = "n")
col = c("red", "blue"),
border = c("green", "yellow"),
lwd = 3, lty = c("dashed", "solid"))
plot(c(1, 9), 1:2, type = "n")
polygon(1:9, c(2,1,2,1,1,2,1,2,1),
col = c("red", "blue"),
border = c("green", "yellow"),
lwd = 3, lty = c("dashed", "solid"))
plot(c(1, 9), 1:2, type = "n")
col = c("red", "blue"),
border = c("green", "yellow"),
lwd = 3, lty = c("dashed", "solid"))
polygon(1:9, c(2,1,2,1,1,2,1,2,1),
col = c("red", "blue"),
border = c("green", "yellow"),
lwd = 3, lty = c("dashed", "solid"))
plot(c(1, 9), 1:2, type = "n")
polygon(1:9, c(2,1,2,1,NA,2,1,2,1),
col = c("red", "blue"),
border = c("green", "yellow"),
lwd = 3, lty = c("dashed", "solid"))
par(op)
# Line-shaded polygons
plot(c(1, 9), 1:2, type = "n")
density = c(10, 20), angle = c(-45, 45))
x <- c(1:9, 8:1)
y <- c(1, 2*(5:3), 2, -1, 17, 9, 8, 2:9)
op <- par(mfcol = c(3, 1))
for(xpd in c(FALSE, TRUE, NA)) {
plot(1:10, main = paste("xpd =", xpd))
box("figure", col = "pink", lwd = 3)
polygon(x, y, xpd = xpd, col = "orange", lty = 2, lwd = 2, border = "red")
}
n <- 100
xx <- c(0:n, n:0)
yy <- c(c(0, cumsum(stats::rnorm(n))), rev(c(0, cumsum(stats::rnorm(n)))))
plot   (xx, yy, type = "n", xlab = "Time", ylab = "Distance")
title("Distance Between Brownian Motions")
# Multiple polygons from NA values
# and recycling of col, border, and lty
op <- par(mfrow = c(2, 1))
plot(c(1, 9), 1:2, type = "n")
col = c("red", "blue"),
border = c("green", "yellow"),
lwd = 3, lty = c("dashed", "solid"))
plot(c(1, 9), 1:2, type = "n")
polygon(1:9, c(2,1,2,1,NA,2,1,2,1),
col = c("red", "blue"),
border = c("green", "yellow"),
lwd = 3, lty = c("dashed", "solid"))
par(op)
# Line-shaded polygons
plot(c(1, 9), 1:2, type = "n")
density = c(10, 20), angle = c(-45, 45))
require(grDevices) # for colours
filled.contour(volcano, color = terrain.colors, asp = 1) # simple
x <- 10*1:nrow(volcano)
y <- 10*1:ncol(volcano)
filled.contour(x, y, volcano, color = terrain.colors,
plot.title = title(main = "The Topography of Maunga Whau",
xlab = "Meters North", ylab = "Meters West"),
plot.axes = { axis(1, seq(100, 800, by = 100))
axis(2, seq(100, 600, by = 100)) },
key.title = title(main = "Height\n(meters)"),
key.axes = axis(4, seq(90, 190, by = 10)))  # maybe also asp = 1
mtext(paste("filled.contour(.) from", R.version.string),
side = 1, line = 4, adj = 1, cex = .66)
# Annotating a filled contour plot
a <- expand.grid(1:20, 1:20)
b <- matrix(a[,1] + a[,2], 20)
filled.contour(x = 1:20, y = 1:20, z = b,
plot.axes = { axis(1); axis(2); points(10, 10) })
## Persian Rug Art:
x <- y <- seq(-4*pi, 4*pi, len = 27)
r <- sqrt(outer(x^2, y^2, "+"))
filled.contour(cos(r^2)*exp(-r/(2*pi)), axes = FALSE)
## rather, the key *should* be labeled:
filled.contour(cos(r^2)*exp(-r/(2*pi)), frame.plot = FALSE,
plot.axes = {})
require(grDevices) # for colours
filled.contour(volcano, color = terrain.colors, asp = 1) # simple
x <- 10*1:nrow(volcano)
y <- 10*1:ncol(volcano)
x
1:nrow(volcano)
terrain.colors
a <- expand.grid(1:20, 1:20)
b <- matrix(a[,1] + a[,2], 20)
filled.contour(x = 1:20, y = 1:20, z = b,
plot.axes = { axis(1); axis(2); points(10, 10) })
a
b
x <- y <- seq(-4*pi, 4*pi, len = 27)
r <- sqrt(outer(x^2, y^2, "+"))
filled.contour(cos(r^2)*exp(-r/(2*pi)), axes = FALSE)
## rather, the key *should* be labeled:
filled.contour(cos(r^2)*exp(-r/(2*pi)), frame.plot = FALSE,
plot.axes = {})
filled.contour(cos(r^2)*exp(-r/(2*pi)), axes = FALSE)
a <- expand.grid(1:20, 1:20)
b <- matrix(a[,1] + a[,2], 20)
filled.contour(x = 1:20, y = 1:20, z = b,
plot.axes = { axis(1); axis(2); points(10, 10) })
yields (0.75, 0.25, 0.5)
col2rgb("#08a0ff")
col2rgb("#08a0ff")
t <- col2rgb("#08a0ff")
attributes(t)
t$dimnames[[1]]
t$[1]
t[1]
t[1][1]
t[[1]]
as.character(t)
col2rgb(c(red = "red", hex = "#abcdef"))
col2rgb(c(palette = 1:3))
t <- col2rgb("#08a0ff")
t
t[,1]
# LAST UPDATED AT 19/1 1pm
#
# NEXT TO DO: LINE 129
# Loading the requiring sources
require("shiny") || install.packages("shiny")
require("DT") || install.packages("DT")
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap/Shiny")
# setwd("/home/cococatty/Desktop/InteractiveMap/Shiny")
# setwd("C:/Users/User/Desktop/InteractiveMap/Shiny")
source("helper.R")
# Initializing the variables
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
, multiple = FALSE
)
, br()
# The following part is groupCheckBox format for the travelMeans
, checkboxGroupInput(
"travelMeans"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
)
, br()
, height = "10%"
),
#Show the map
mainPanel(
h3("Map of New Zealand", align = "center")
, tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", DT::dataTableOutput("onetable"), hr()
, verbatimTextOutput("singleTableText")
)
, tabPanel("Single-Mean Plot", plotOutput("oneMap"))
, tabPanel("Two-way table", DT::dataTableOutput("biTable") # , height = "100%"
, verbatimTextOutput("biTableText")
)
, tabPanel("Two-Mean Plot", plotOutput("biMap"))
)
, position="center"
#, width= "auto" # THIS MAKES THE "UGLY LOOK" (DETAILS AT THE BOTTOM)
, height= "auto"
)
)
#Definte server logic required to draw the map
server <- function(input, output, session) {
updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMeans, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
})
######## TBC -- NEED TO FIX THE ROW NUMBER!! ######################################################################
output$onetable <- DT::renderDataTable({
DT::datatable(
updateoneTable(), selection = "single" #list(target="cell")
)}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = TRUE)
#, caption = paste("Travel mean: ", tail(input$travelMeans, 1)) ######## NOT WORKING
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
, server = TRUE
)
output$singleTableText <- renderPrint({
s = input$onetable_rows_selected
if (length(s)) {
cat('These rows were selected:\n\n')
cat(s, sep = ', ')
}
})
observe({
if (length(input$travelMeans) > maxGrp)
{
updateCheckboxGroupInput(session, 'travelMeans', selected = tail(input$travelMeans,maxGrp))
}
})
biTable <- reactive({
return(biTableMatrix(input$travelMeans))
})
######## TBC -- NEED TO SHOW THE ROW NUMBER!! ######################################################################
output$biTable <- DT::renderDataTable({
DT::datatable(
biTable()
, extensions = "Scroller"
, options = list(
deferRender = TRUE
, dom = "frtiS"#frtiS
, scrollY = 200
, scrollCollapse = TRUE
, autoWidth = TRUE
)
# , rownames = TRUE ######## NOT WORKING
)
})
######## TBC -- NOT WORKING!! ######################################################################
output$biTableText <- renderPrint({
sb = input$biTable_rows_selected
if (length(sb)) {
cat('These rows were selected:\n\n')
cat(sb, sep = ', ')
}
})
#geodata[geodata$AreaCode] "x47"
output$text1 <- renderText({paste("Travel mean: ", input$travelMeans, collapse = ',')})
output$text2 <- renderText({paste("Selected ", input$categories, " categories")})
output$oneMap <- renderPlot(singleMap(input$categories, input$travelMeans, input$classIntMethod))
output$biMap  <- renderPlot(biMap(input$travelMeans))
}
shinyApp(ui = ui, server = server)
