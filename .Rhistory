#head(newtable)
#remove(newtable)
#Assigning data
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
nz_map <- function(numQUan, travelMean, classIntMethod)
{
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 2)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 2)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 2)
}
colPal <- findColours(nclass, pal(length(nclass$brks-1)))
#head(shape@data)
#Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:length(nclass$brks))
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 2), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(length(nclass$brks)-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(length(nclass$brks)-1), bty = 'o')#, pch= 1
}
#nz_map(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
head(shape@data)
head(probList)
colr <- colorRampPalette(c("white", "red"), space= "rgb")
colb <- colorRampPalette(c("white", "blue"), space= "rgb")
colr <- colorRampPalette(c("white", "red"), space= "rgb")
colb <- colorRampPalette(c("white", "blue"), space= "rgb")
head(geodata)
head(shape@data)
geodata$Weight <- c(0)
geodata
geodata$Weight <- NULL
geodata$Weight
maxList <- setNames(aggregate(geodata$Percentage, by=list(geodata$MeanCode), max), c('MeanCode', 'Max'))
remove(probList)
bike <- subset(geodata[((geodata$MeanCode %in% c('09', '02'))
#, '15')
),] , select=-c(AreaName, AreaFull, MeanFull,MeanName))
bike
levels(bike$AreaCode)
length(levels(bike$AreaCode))
geodata
head(geodata)
newMatrix <- matrix(nrow = n, ncol = n)
is.matrix(as.matrix(1:10))
!is.matrix(warpbreaks)  # data.frame, NOT matrix!
warpbreaks[1:10,]
as.matrix(warpbreaks[1:10,])  # using as.matrix.data.frame(.) method
## Example of setting row and column names
mdat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,
dimnames = list(c("row1", "row2"),
c("C.1", "C.2", "C.3")))
mdat
array(2:6)
array(2:6, c(68,68))
r <- matrix(runif(9, 0, 1), 3)
g <- matrix(runif(9, 0, 1), 3)
b <- matrix(runif(9, 0, 1), 3)
col <- rgb(r, g, b)
dim(col) <- dim(r)
library(grid)
grid.raster(col, interpolate=FALSE)
col
dim(r)
r
g
plot(g)
plot(r,g,b)
plot(r)
plot(g)
plot(r)
plot(g)
plot(b)
## Both return a *function* :
colorRamp(c("red", "green"))( (0:4)/4 ) ## (x) , x in [0,1]
colorRampPalette(c("blue", "red"))( 4 ) ## (n)
## a ramp in opacity of blue values
colorRampPalette(c(rgb(0,0,1,1), rgb(0,0,1,0)), alpha = TRUE)(8)
require(graphics)
## Here space="rgb" gives palettes that vary only in saturation,
## as intended.
## With space="Lab" the steps are more uniform, but the hues
## are slightly purple.
filled.contour(volcano,
color.palette =
colorRampPalette(c("red", "white", "blue")),
asp = 1)
filled.contour(volcano,
color.palette =
colorRampPalette(c("red", "white", "blue"),
space = "Lab"),
asp = 1)
## Interpolating a 'sequential' ColorBrewer palette
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")
filled.contour(volcano,
color.palette = colorRampPalette(YlOrBr, space = "Lab"),
asp = 1)
filled.contour(volcano,
color.palette = colorRampPalette(YlOrBr, space = "Lab",
bias = 0.5),
asp = 1)
## 'jet.colors' is "as in Matlab"
## (and hurting the eyes by over-saturation)
jet.colors <-
colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
"#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))
filled.contour(volcano, color = jet.colors, asp = 1)
## space="Lab" helps when colors don't form a natural sequence
m <- outer(1:20,1:20,function(x,y) sin(sqrt(x*y)/3))
rgb.palette <- colorRampPalette(c("red", "orange", "blue"),
space = "rgb")
Lab.palette <- colorRampPalette(c("red", "orange", "blue"),
space = "Lab")
filled.contour(m, col = rgb.palette(20))
filled.contour(m, col = Lab.palette(20))
rgb(255,255,0)
rgb(0.4,0.5,0)
geodata$Percentage
head(geodata)
#Clearing up the data
rm(list=ls())
#Loading the requiring sources
library(maptools)
library(classInt)
library(stringr)
library(colorRamps)
#Initializing the variables
travelMean <- c()
#Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/GitHub/InteractiveMap")
geodata <- read.csv('geodata.csv'
, col.names= c('AreaCode','AreaName','AreaFull','MeanCode','MeanName','MeanFull','Ppl')
, header= FALSE
, sep = ','
, numerals = c('no.loss'))
# Remove
geodata <- geodata[!(geodata$MeanCode == 'MeanCode' & geodata$AreaCode == 'AreaCode'), ]
#head(geodata)
meandata <- unique(geodata[c('MeanCode', 'MeanName', 'MeanFull') ] )
meandata <- meandata[order(meandata$MeanName),]
meanChoices <- as.character(meandata$MeanCode)
names(meanChoices) <- meandata$MeanName
#Create a new column "Percentage" in geodata
geodata$Percentage <- c(0)
#Create a list with the Areas and the total numbers of ppl
totalList <- setNames(aggregate(as.numeric(levels(geodata$Ppl)[geodata$Ppl]), by=list(Area=geodata$AreaCode), FUN = sum)
, c('AreaCode', 'Total')
)
#head(geodata)
#Calculate the percentages within Areas
for (i in 1:length(geodata$Percentage))
{
rowPpl <- as.numeric(levels(geodata$Ppl[i])[geodata$Ppl[i]])
rowTotal <- ((totalList[totalList$AreaCode == geodata$AreaCode[i],]) $Total)
geodata$Percentage[i] <- (rowPpl / rowTotal)
}
# Get ready for the two-way table
maxList <- setNames(aggregate(geodata$Percentage, by=list(geodata$MeanCode), max), c('MeanCode', 'Max'))
#Reading and merging the shapefiles
shape <- readShapeSpatial("./Shapefiles/TA2013_GV_Clipped.shp")
shape <- shape[!(shape@data$TA2013_NAM == 'Chatham Islands Territory' | shape@data$TA2013_NAM == 'Area Outside Territorial Authority'),]
shape@data <- merge(shape@data,geodata,by.x="TA2013",by.y="AreaCode", all.x= TRUE )#, replace = TRUE
shape@data$Ppl <- as.numeric(levels(shape@data$Ppl)[shape@data$Ppl])
shape@data$Percentage[is.na(shape@data$Percentage)] <- 0
shape@data$Percentage <- round(shape@data$Percentage*100,2)
newtable <- subset(shape@data)
newtable <- subset(newtable, select = -c(TA2013, TA2013_NAM, MeanFull, AreaFull))
#head(newtable)
#remove(newtable)
#Assigning data
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
singleMap <- function(numQUan, travelMean, classIntMethod)
{
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 2)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 2)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 2)
}
colPal <- findColours(nclass, pal(length(nclass$brks-1)))
#head(shape@data)
#Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:length(nclass$brks))
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 2), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(length(nclass$brks)-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(length(nclass$brks)-1), bty = 'o')#, pch= 1
}
#singleMap(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
library(shiny)
library(DT)
setwd("//file/UsersY$/yzh215/Home/Desktop/GitHub/InteractiveMap/Shiny")
source("helper.R")
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
#                        , selectize = FALSE
, multiple = FALSE
#                        , width = "auto"
)
, br()
# The following part is SelectInput format for the TravelMean
#         selectInput("travelMean", "Travel Mean"
#                       , label = "Select the mean below:"
#                       , choices = meanChoices
#                       , multiple = TRUE
#                       , width = "100%"
#         )
# The following part is groupCheckBox format for the TravelMean
, checkboxGroupInput(
"travelMean"
#                    , "Travel Mean"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
#, inline = FALSE
)
, br()
, height = "10%"
),
#Show the map
mainPanel(
h3("Map of New Zealand", align = "center")
, h4(textOutput("text1"), align = "center")
, h4(textOutput("text2"), align = "center")
, h4("Data is in percentages", align = "center")
, tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", tableOutput("onetable")  )
, tabPanel("Single-Mean Plot", plotOutput("oneMap"))
, tabPanel("Two-Mean Table", tableOutput("biTable")  )
, tabPanel("Two-Mean Plot", plotOutput("biMap"))
)
, position="center"
, width= "auto"
, height= "auto"
)
)
#Definte server logic required to draw the map
server <- function(input, output, session) {
updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMean, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
})
output$onetable <- renderTable({
updateoneTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", tail(input$travelMean, 1))
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
#, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight')
)
#test <- reactive({ length(input$travelMean)})
#test1 <- reactive({ input$travelMean})
test <- reactive({summary(input$travelMean) })
test
observe({
if (length(input$travelMean) > maxGrp)
{
updateCheckboxGroupInput(session, 'travelMean', selected = tail(input$travelMean,maxGrp))
}
#
#       if (length(input$travelMean) < minGrp)
#       {
#         updateCheckboxGroupInput(session, 'travelMean', selected = as.character(meandata$MeanCode[1]))
#       }
})
updatebiTable <- reactive({
biTable <- subset(newtable, newtable$MeanCode == input$travelMean, select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
biTable <- biTable[order(biTable$Percentage),]
})
output$biTable <- renderTable({
updatebiTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", input$travelMean, 1)
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
)
output$text1 <- renderText({paste("Travel mean: ", input$travelMean, collapse = ',')})
#output$text1 <- renderText({paste("Travel mean: ", input$travelMean)})
output$text2 <- renderText({paste("Selected ", input$categories, " categories")})
output$oneMap <- renderPlot(singleMap(input$categories, input$travelMean, input$classIntMethod))
output$biMap  <- renderPlot(singleMap(input$categories, input$travelMean, input$classIntMethod))
}
shinyApp(ui = ui, server = server)
geodata[geodata$MeanCode=='02']
geodata[geodata$MeanCode=='02',]
listx <- subset(geodata[geodata$MeanCode=='02',], select=-c(MeanFull,AreaFull,AreaName, MeanName))
listx
head(listx)
plot(1,col = rgb(1,0,0,alpha =0.8))
plot(1,col = rgb(0,0,255, alpha=254,
maxColorValue=255))
plot(1,col = rgb(1,0,0,alpha =0.8))
# as long as alpha < 1, there is no point in the plot.
plot(1,col = rgb(1,0,0,alpha =0.1))
plot(1,col = rgb(1,0,0,alpha =1))
colPal
numQUan=5
travelMean = c('03')#c('03','09')
classIntMethod="pretty"
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 2)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 2)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 2)
}
colPal <- findColours(nclass, pal(length(nclass$brks-1)))
#head(shape@data)
colPal
attribute(colPal)
attributes(colPal)
#Clearing up the data
rm(list=ls())
pck <- c("maptools", "classInt", "stringr", "colorRamps")
require(pck) || install.packages(pck)
#Loading the requiring sources
# library(maptools)
# library(classInt)
# library(stringr)
# library(colorRamps)
#Initializing the variables
travelMean <- c()
#Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/GitHub/InteractiveMap")
geodata <- read.csv('geodata.csv'
, col.names= c('AreaCode','AreaName','AreaFull','MeanCode','MeanName','MeanFull','Ppl')
, header= FALSE
, sep = ','
, numerals = c('no.loss'))
# Remove
geodata <- geodata[!(geodata$MeanCode == 'MeanCode' & geodata$AreaCode == 'AreaCode'), ]
#head(geodata)
meandata <- unique(geodata[c('MeanCode', 'MeanName', 'MeanFull') ] )
meandata <- meandata[order(meandata$MeanName),]
meanChoices <- as.character(meandata$MeanCode)
names(meanChoices) <- meandata$MeanName
#Create a new column "Percentage" in geodata
geodata$Percentage <- c(0)
#Create a list with the Areas and the total numbers of ppl
totalList <- setNames(aggregate(as.numeric(levels(geodata$Ppl)[geodata$Ppl]), by=list(Area=geodata$AreaCode), FUN = sum)
, c('AreaCode', 'Total')
)
#head(geodata)
#Calculate the percentages within Areas
for (i in 1:length(geodata$Percentage))
{
rowPpl <- as.numeric(levels(geodata$Ppl[i])[geodata$Ppl[i]])
rowTotal <- ((totalList[totalList$AreaCode == geodata$AreaCode[i],]) $Total)
geodata$Percentage[i] <- (rowPpl / rowTotal)
}
# Get ready for the two-way table
maxList <- setNames(aggregate(geodata$Percentage, by=list(geodata$MeanCode), max), c('MeanCode', 'Max'))
#Reading and merging the shapefiles
shape <- readShapeSpatial("./Shapefiles/TA2013_GV_Clipped.shp")
shape <- shape[!(shape@data$TA2013_NAM == 'Chatham Islands Territory' | shape@data$TA2013_NAM == 'Area Outside Territorial Authority'),]
shape@data <- merge(shape@data,geodata,by.x="TA2013",by.y="AreaCode", all.x= TRUE )#, replace = TRUE
shape@data$Ppl <- as.numeric(levels(shape@data$Ppl)[shape@data$Ppl])
shape@data$Percentage[is.na(shape@data$Percentage)] <- 0
shape@data$Percentage <- round(shape@data$Percentage*100,2)
newtable <- subset(shape@data)
newtable <- subset(newtable, select = -c(TA2013, TA2013_NAM, MeanFull, AreaFull))
#head(newtable)
#remove(newtable)
#Assigning data
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
singleMap <- function(numQUan, travelMean, classIntMethod)
{
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 2)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 2)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 2)
}
colPal <- findColours(nclass, pal(length(nclass$brks-1)))
#head(shape@data)
#Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
#  attributes(colPal)
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:length(nclass$brks))
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 2), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(length(nclass$brks)-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(length(nclass$brks)-1), bty = 'o')#, pch= 1
}
biMap <- function(numQUan, travelMean, classIntMethod)
{
redpal <-
#Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:length(nclass$brks))
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 2), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(length(nclass$brks)-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(length(nclass$brks)-1), bty = 'o')#, pch= 1
}
#singleMap(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
install.packages(pck)
maxList
