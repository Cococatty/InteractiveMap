matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1),
col=ColorRamp,
xlab="",ylab="",
xaxt="n")
layout(1)
}
# ----- END plot function ----- #
tmat <- matrix(random(25), nrow=5,ncol=5)
rand(25)
number(25)
rnorm(25)
tmat <- matrix(rnorm(25), nrow=5,ncol=5)
myImagePlot(tmat)
x <- tmat
min <- min(x)
max <- max(x)
min
yLabels <- rownames(x)
xLabels <- colnames(x)
title <-c()
xLabels
colnames(x)
if( length(list(...)) ){
Lst <- list(...)
if( !is.null(Lst$zlim) ){
min <- Lst$zlim[1]
max <- Lst$zlim[2]
}
if( !is.null(Lst$yLabels) ){
yLabels <- c(Lst$yLabels)
}
if( !is.null(Lst$xLabels) ){
xLabels <- c(Lst$xLabels)
}
if( !is.null(Lst$title) ){
title <- Lst$title
}
}
title
# check for null values
if( is.null(xLabels) ){
xLabels <- c(1:ncol(x))
}
if( is.null(yLabels) ){
yLabels <- c(1:nrow(x))
}
xLabels
layout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))
ColorRamp <- rgb( seq(0,1,length=256),  # Red
seq(0,1,length=256),  # Green
seq(1,0,length=256))  # Blue
ColorRamp
seq(0,1,length=256)
seq(1,0,length=256)
seq(min, max, length=length(ColorRamp))
ColorLevels
ColorLevels <- seq(min, max, length=length(ColorRamp))
ColorLevels
reverse <- nrow(x) : 1
reverse
yLabels <- yLabels[reverse]
x <- x[reverse,]
par(mar = c(3,5,2.5,2))
image(1:length(xLabels), 1:length(yLabels), t(x), col=ColorRamp, xlab="",
ylab="", axes=FALSE, zlim=c(min,max))
image(1:length(xLabels), 1:length(yLabels), t(x), col=ColorRamp, xlab="",
ylab="", axes=FALSE, zlim=c(min,max))
if( !is.null(title) ){
title(main=title)
}
axis(BELOW<-1, at=1:length(xLabels), labels=xLabels, cex.axis=0.7)
axis(LEFT <-2, at=1:length(yLabels), labels=yLabels, las= HORIZONTAL<-1,
cex.axis=0.7)
# Color Scale
par(mar = c(3,2.5,2.5,2))
image(1, ColorLevels,
matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1),
col=ColorRamp,
xlab="",ylab="",
xaxt="n")
layout(1)
myImagePlot(tmat)
myImagePlot(tmat)
myImagePlot(tmat)
tmat
rDevices)
matplot((-4:5)^2, main = "Quadratic") # almost identical to plot(*)
sines <- outer(1:20, 1:4, function(x, y) sin(x / 20 * pi * y))
matplot(sines, pch = 1:4, type = "o", col = rainbow(ncol(sines)))
matplot(sines, type = "b", pch = 21:23, col = 2:5, bg = 2:5,
main = "matplot(...., pch = 21:23, bg = 2:5)")
x <- 0:50/50
matplot(x, outer(x, 1:8, function(x, k) sin(k*pi * x)),
ylim = c(-2,2), type = "plobcsSh",
main= "matplot(,type = \"plobcsSh\" )")
## pch & type =  vector of 1-chars :
matplot(x, outer(x, 1:4, function(x, k) sin(k*pi * x)),
pch = letters[1:4], type = c("b","p","o"))
lends <- c("round","butt","square")
matplot(matrix(1:12, 4), type="c", lty=1, lwd=10, lend=lends)
text(cbind(2.5, 2*c(1,3,5)-.4), lends, col= 1:3, cex = 1.5)
table(iris$Species) # is data.frame with 'Species' factor
iS <- iris$Species == "setosa"
iV <- iris$Species == "versicolor"
op <- par(bg = "bisque")
matplot(c(1, 8), c(0, 4.5), type =  "n", xlab = "Length", ylab = "Width",
main = "Petal and Sepal Dimensions in Iris Blossoms")
matpoints(iris[iS,c(1,3)], iris[iS,c(2,4)], pch = "sS", col = c(2,4))
matpoints(iris[iV,c(1,3)], iris[iV,c(2,4)], pch = "vV", col = c(2,4))
legend(1, 4, c("    Setosa Petals", "    Setosa Sepals",
"Versicolor Petals", "Versicolor Sepals"),
pch = "sSvV", col = rep(c(2,4), 2))
nam.var <- colnames(iris)[-5]
nam.spec <- as.character(iris[1+50*0:2, "Species"])
iris.S <- array(NA, dim = c(50,4,3),
dimnames = list(NULL, nam.var, nam.spec))
for(i in 1:3) iris.S[,,i] <- data.matrix(iris[1:50+50*(i-1), -5])
matplot(iris.S[, "Petal.Length",], iris.S[, "Petal.Width",], pch = "SCV",
col = rainbow(3, start = 0.8, end = 0.1),
sub = paste(c("S", "C", "V"), dimnames(iris.S)[[3]],
sep = "=", collapse= ",  "),
main = "Fisher's Iris Data")
par(op)
legend('bottomright', legend= seq(5), title = 'Legend', fill= rpal, bty = 'o')#, pch= 1
legend('bottomright', legend= seq(5*5), title = 'Legend', fill= rpal, bty = 'o')#, pch= 1
dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))
library(ggplot2)
ggplot(dat, aes(x=red, y=blue)) +
geom_tile(aes(fill=mix), color="white") +
scale_fill_identity()
val2col<-function(z, zlim, col = heat.colors(12), breaks){
if(!missing(breaks)){
if(length(breaks) != (length(col)+1)){stop("must have one more break than colour")}
}
if(missing(breaks) & !missing(zlim)){
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
if(missing(breaks) & missing(zlim)){
zlim <- range(z, na.rm=TRUE)
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
colorlevels <- col[((as.vector(z)-breaks[1])/(range(breaks)[2]-range(breaks)[1]))*(length(breaks)-1)+1] # assign colors to heights for each point
colorlevels
}
#data
x <- seq(100)
y <- seq(100)
grd <- expand.grid(x=x,y=y)
#assign colors to grd levels
pal1 <- colorRampPalette(c("white", rgb(1,0,0)), space = "rgb")
col1 <- val2col(x, col=pal1(10))
pal2 <- colorRampPalette(c("white", rgb(0,0,1)), space = "rgb")
col2 <- val2col(y, col=pal2(10))
col3 <- NA*seq(nrow(grd))
for(i in seq(nrow(grd))){
xpos <- grd$x[i]
ypos <- grd$y[i]
coltmp <- (col2rgb(col1[xpos])/2) + (col2rgb(col2[ypos])/2)
col3[i] <- rgb(coltmp[1], coltmp[2], coltmp[3], maxColorValue = 255)
}
#plot
png("2_color_scales.png", width=6, height=4, units="in", res=200)
layout(matrix(c(1,2,3), nrow=1, ncol=3), widths=c(4,1,1), heights=4, respect=T)
par(mar=c(4,4,2,2))
plot(grd,col=col3, pch=19)
par(mar=c(4,0,2,5))
image(x=1, y=x, z=t(as.matrix(x)), col=pal1(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("x", side=4, line=3, cex=0.7)
par(mar=c(4,0,2,5))
image(x=1, y=y, z=t(as.matrix(y)), col=pal2(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("y", side=4, line=3, cex=0.7)
dev.off()
val2col<-function(z, zlim, col = heat.colors(12), breaks){
if(!missing(breaks)){
if(length(breaks) != (length(col)+1)){stop("must have one more break than colour")}
}
if(missing(breaks) & !missing(zlim)){
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
if(missing(breaks) & missing(zlim)){
zlim <- range(z, na.rm=TRUE)
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
colorlevels <- col[((as.vector(z)-breaks[1])/(range(breaks)[2]-range(breaks)[1]))*(length(breaks)-1)+1] # assign colors to heights for each point
colorlevels
}
#data
x <- seq(100)
y <- seq(100)
grd <- expand.grid(x=x,y=y)
#assign colors to grd levels
pal1 <- colorRampPalette(c("white", rgb(1,0,0)), space = "rgb")
col1 <- val2col(x, col=pal1(10))
pal2 <- colorRampPalette(c("white", rgb(0,0,1)), space = "rgb")
col2 <- val2col(y, col=pal2(10))
col3 <- NA*seq(nrow(grd))
for(i in seq(nrow(grd))){
xpos <- grd$x[i]
ypos <- grd$y[i]
coltmp <- (col2rgb(col1[xpos])/2) + (col2rgb(col2[ypos])/2)
col3[i] <- rgb(coltmp[1], coltmp[2], coltmp[3], maxColorValue = 255)
}
#plot
png("2_color_scales.png", width=6, height=4, units="in", res=200)
layout(matrix(c(1,2,3), nrow=1, ncol=3), widths=c(4,1,1), heights=4, respect=T)
par(mar=c(4,4,2,2))
plot(grd,col=col3, pch=19)
par(mar=c(4,0,2,5))
image(x=1, y=x, z=t(as.matrix(x)), col=pal1(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("x", side=4, line=3, cex=0.7)
par(mar=c(4,0,2,5))
image(x=1, y=y, z=t(as.matrix(y)), col=pal2(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("y", side=4, line=3, cex=0.7)
dev.off()
val2col<-function(z, zlim, col = heat.colors(12), breaks){
if(!missing(breaks)){
if(length(breaks) != (length(col)+1)){stop("must have one more break than colour")}
}
if(missing(breaks) & !missing(zlim)){
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
if(missing(breaks) & missing(zlim)){
zlim <- range(z, na.rm=TRUE)
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
colorlevels <- col[((as.vector(z)-breaks[1])/(range(breaks)[2]-range(breaks)[1]))*(length(breaks)-1)+1] # assign colors to heights for each point
colorlevels
}
x <- seq(100)
y <- seq(100)
grd <- expand.grid(x=x,y=y)
#assign colors to grd levels
pal1 <- colorRampPalette(c("white", rgb(1,0,0)), space = "rgb")
col1 <- val2col(x, col=pal1(10))
pal2 <- colorRampPalette(c("white", rgb(0,0,1)), space = "rgb")
col2 <- val2col(y, col=pal2(10))
col3 <- NA*seq(nrow(grd))
for(i in seq(nrow(grd))){
xpos <- grd$x[i]
ypos <- grd$y[i]
coltmp <- (col2rgb(col1[xpos])/2) + (col2rgb(col2[ypos])/2)
col3[i] <- rgb(coltmp[1], coltmp[2], coltmp[3], maxColorValue = 255)
}
#plot
png("2_color_scales.png", width=6, height=4, units="in", res=200)
layout(matrix(c(1,2,3), nrow=1, ncol=3), widths=c(4,1,1), heights=4, respect=T)
par(mar=c(4,4,2,2))
plot(grd,col=col3, pch=19)
par(mar=c(4,0,2,5))
image(x=1, y=x, z=t(as.matrix(x)), col=pal1(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("x", side=4, line=3, cex=0.7)
par(mar=c(4,0,2,5))
image(x=1, y=y, z=t(as.matrix(y)), col=pal2(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("y", side=4, line=3, cex=0.7)
val2col<-function(z, zlim, col = heat.colors(12), breaks){
if(!missing(breaks)){
if(length(breaks) != (length(col)+1)){stop("must have one more break than colour")}
}
if(missing(breaks) & !missing(zlim)){
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
if(missing(breaks) & missing(zlim)){
zlim <- range(z, na.rm=TRUE)
zlim[2] <- zlim[2]+c(zlim[2]-zlim[1])*(1E-3)#adds a bit to the range in both directions
zlim[1] <- zlim[1]-c(zlim[2]-zlim[1])*(1E-3)
breaks <- seq(zlim[1], zlim[2], length.out=(length(col)+1))
}
colorlevels <- col[((as.vector(z)-breaks[1])/(range(breaks)[2]-range(breaks)[1]))*(length(breaks)-1)+1] # assign colors to heights for each point
colorlevels
}
#data
x <- seq(100)
y <- seq(100)
grd <- expand.grid(x=x,y=y)
#assign colors to grd levels
pal1 <- colorRampPalette(c("white", rgb(1,0,0)), space = "rgb")
col1 <- val2col(x, col=pal1(10))
pal2 <- colorRampPalette(c("white", rgb(0,0,1)), space = "rgb")
col2 <- val2col(y, col=pal2(10))
col3 <- NA*seq(nrow(grd))
for(i in seq(nrow(grd))){
xpos <- grd$x[i]
ypos <- grd$y[i]
coltmp <- (col2rgb(col1[xpos])/2) + (col2rgb(col2[ypos])/2)
col3[i] <- rgb(coltmp[1], coltmp[2], coltmp[3], maxColorValue = 255)
}
#plot
png("2_color_scales.png", width=6, height=4, units="in", res=200)
layout(matrix(c(1,2,3), nrow=1, ncol=3), widths=c(4,1,1), heights=4, respect=T)
par(mar=c(4,4,2,2))
plot(grd,col=col3, pch=19)
par(mar=c(4,0,2,5))
image(x=1, y=x, z=t(as.matrix(x)), col=pal1(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("x", side=4, line=3, cex=0.7)
par(mar=c(4,0,2,5))
image(x=1, y=y, z=t(as.matrix(y)), col=pal2(10), xaxt="n", yaxt="n", xlab="", ylab="")
box()
axis(4)
mtext("y", side=4, line=3, cex=0.7)
dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))
dat
dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))
library(ggplot2)
ggplot(dat, aes(x=red, y=blue)) +
geom_tile(aes(fill=mix), color="white") +
scale_fill_identity()
travelMeans <- c('02', '04')
test <- prepareTwoMeans(travelMeans)
test
library(ggplot2)
ggplot(test, aes(x=xpos, y=ypos)) +
geom_tile(aes(fill=mix), color="white") +
scale_fill_identity()
dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))
library(ggplot2)
ggplot(dat, aes(x=red, y=blue)) +
geom_tile(aes(fill=mix), color="white") +
scale_fill_identity()
ggplot(test, aes(x=test$xpos, y=test$ypos)) +
geom_tile(aes(fill=test$mix), color="white") +
scale_fill_identity()
library(ggplot2)
ggplot(test, aes(x=test$xpos, y=test$ypos)) +
geom_tile(aes(fill=test$mix), color="white") +
scale_fill_identity()
test
ggplot(test, aes(x=test$xpos, y=test$ypos))
mix <- test$mix
ggplot(test, aes(x=test$xpos, y=test$ypos)) +
geom_tile(aes(fill=test$mix), color="white") +
scale_fill_identity()
mix <- test$mix
ggplot(test, aes(x=test$xpos, y=test$ypos)) +
geom_tile(aes(fill=test$mix), color="black") +
scale_fill_identity()
plot.new()
mix <- test$mix
ggplot(test, aes(x=test$xpos, y=test$ypos)) +
geom_tile(aes(fill=test$mix), color="black") +
scale_fill_identity()
dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))
library(ggplot2)
ggplot(dat, aes(x=red, y=blue)) +
geom_tile(aes(fill=mix), color="white") +
scale_fill_identity()
dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))
dat
library(ggplot2)
ggplot(dat, aes(x=red, y=blue)) +
geom_tile(aes(fill=mix), color="white") +
scale_fill_identity()
# LAST UPDATED AT 28/1 17.26
#
# NEXT TO DO: CHANGE THE "MIX" TO A MEANINGFUL NAME
# Clearing up the data
# rm(list=ls())
# Loading the requiring sources
require("classInt") || install.packages("classInt")
require("colorRamps") || install.packages("colorRamps")
require("maptools") || install.packages("maptools")
require("stringr") || install.packages("stringr")
# Initializing the variables
travelMean <- c()
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap")
# Reading required data
# geodata contains various travel means and the number of people travel in the means
geodata <- read.csv('geodata.csv'
, col.names= c('AreaCode','AreaName','AreaFull','MeanCode','MeanName','MeanFull','Ppl')
, header= FALSE
, sep = ','
, numerals = c('no.loss'))
# Remove the header from the data - cannot set "header = TRUE" in previous section because it
# would trim the 0s away from Mean codes and Area codes.
geodata <- geodata[!(geodata$MeanCode == 'MeanCode' & geodata$AreaCode == 'AreaCode'), ]
# Generating the details of travel means
meandata <- unique(geodata[c('MeanCode', 'MeanName', 'MeanFull') ] )
meandata <- meandata[order(meandata$MeanName),]
# Generating the list of choices for the Travel means input in UI
meanChoices <- as.character(meandata$MeanCode)
names(meanChoices) <- meandata$MeanName
# Create a new column "Percentage" in geodata
geodata$Percentage <- c(0)
# Create a list with the Areas and the total numbers of ppl
totalList <- setNames(aggregate(as.numeric(levels(geodata$Ppl)[geodata$Ppl]), by=list(Area=geodata$AreaCode), FUN = sum)
, c('AreaCode', 'Total')
)
# Calculate the percentages within Areas
for (i in 1:nrow(geodata))
{
rowPpl <- as.numeric(levels(geodata$Ppl[i])[geodata$Ppl[i]])
rowTotal <- ((totalList[totalList$AreaCode == geodata$AreaCode[i],]) $Total)
geodata$Percentage[i] <- (rowPpl / rowTotal)
}
# Reading and merging the shapefiles
shape <- readShapeSpatial("./Shapefiles/TA2013_GV_Clipped.shp")
shape <- shape[!(shape@data$TA2013_NAM == 'Chatham Islands Territory' | shape@data$TA2013_NAM == 'Area Outside Territorial Authority'),]
shape@data <- merge(shape@data,geodata,by.x="TA2013",by.y="AreaCode", all.x= TRUE )#, replace = TRUE
shape@data$Ppl <- as.numeric(levels(shape@data$Ppl)[shape@data$Ppl])
shape@data$Percentage[is.na(shape@data$Percentage)] <- 0
shape@data$Percentage <- round(shape@data$Percentage*100,1)
# Generating the base of the singleTable (table for single travel mean) in UI
newtable <- subset(shape@data)
newtable <- subset(newtable, select = -c(TA2013, TA2013_NAM, MeanFull, AreaFull))
# This function plots the colored map of single travel mean
singleMap <- function(numQUan, travelMean, classIntMethod)
{
# Defining the color data for single table
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 1)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 1)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 1)
}
len <- length(nclass$brks)
colPal <- findColours(nclass, pal(len))
# Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:len)
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 1), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(len-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
#legend('bottomright', legend= nclass$brk, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
}
prepareTwoMeans <- function(travelMeans) {
listx <- subset(newtable[newtable$MeanCode==travelMeans[1],])
listx <- listx[order(listx$Percentage),]
listy <- subset(newtable[newtable$MeanCode==travelMeans[2],], select = -c(MeanName))
listy <- listy[order(listy$Percentage),]
listx$xpos <- seq(nrow(listx))
listy$ypos <- seq(nrow(listy))
listx <- merge(listx, listy, by.x = c("AreaName"), by.y = c("AreaName"), all=TRUE)
listx <- within(listx, mix <- rgb(red=255*listx$x/nrow(listx), green=0, blue=255*listx$y/nrow(listx)
, maxColorValue=255))
return(listx)
}
# This function plots the colored map of two travel means
biMap <- function(travelMeans)
{
fullList <- prepareTwoMeans(travelMeans)
plot(shape, legend=FALSE, border = "Black", col= fullList$mix)
#legend('bottomright', legend = "x,y", title = 'Legend', fill= pal(fullList$mix), bty = 'o')#, pch= 1
}
#singleMap(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
dat <- expand.grid(blue=seq(0, 100, by=10), red=seq(0, 100, by=10))
dat <- within(dat, mix <- rgb(green=0, red=red, blue=blue, maxColorValue=100))
library(ggplot2)
ggplot(dat, aes(x=red, y=blue)) +
geom_tile(aes(fill=mix), color="white") +
scale_fill_identity()
