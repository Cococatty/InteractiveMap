list("Sepal length" = "Sepal.Length",
"Sepal width"  = "Sepal.Width",
"Petal length" = "Petal.Length",
"Petal width"  = "Petal.Width")),
selectInput("variable2", "Second variable:",
list("Sepal length" = "Sepal.Length",
"Sepal width"  = "Sepal.Width",
"Petal length" = "Petal.Length",
"Petal width"  = "Petal.Width"))
),
mainPanel(
h3(textOutput("caption")),
plotOutput("plot")
)
))
library(shiny)
library(datasets)
library(ggplot2)
data <- iris
# Define server logic required to plot variables
shinyServer(function(input, output) {
# Create a reactive text
text <- reactive({
paste(input$variable, 'versus', input$variable2)
})
# Return as text the selected variables
output$caption <- renderText({
text()
})
# Generate a plot of the requested variables
output$plot <- renderPlot({
p <- ggplot(data, aes_string(x=input$variable, y=input$variable2, colour="Species")) + geom_point()
print(p)
})
})
shiny::runApp('//file/UsersY$/yzh215/Home/Desktop/InteractiveMap/Design/1')
#enter any requires/library here
require(quantmod)
#require(PerformanceAnalytics)
shinyServer(function(input, output) {
#use the structure from trestletechnology example to load data
data <- reactive(function(){
getSymbols(c('VBMFX','VFINX','VDMIX','VEIEX'))
#combine date from xts and coredata to get a data.frame in the format best for JSON pass in Shiny
prices <- na.omit(merge(to.monthly(VBMFX)[,6],to.monthly(VFINX)[,6],to.monthly(VDMIX)[,6],to.monthly(VEIEX)[,6]))
returns <- prices / lag(prices, k=1) - 1
returns[1,] <- 0
data <- cbind(coredata(returns),format(index(returns),"%Y-%m-%d"))
#name columns same as the example
colnames(data) <- c('VBMFX','VFINX','VDMIX','VEIEX','Date')
data
})
output$scatterplot <- reactive(function() { data() })
})
shiny::runApp('//file/UsersY$/yzh215/Home/Desktop/InteractiveMap/Design/1')
#R and Shiny adaptation of http://bl.ocks.org/4063663
reactiveSvg <- function (outputId)
{
HTML(paste("<div id=\"", outputId, "\" class=\"shiny-network-output\"><svg /></div>", sep=""))
}
shinyUI(pageWithSidebar(
headerPanel(title=HTML("Shiny and R adaptation of <a href = \"http://bl.ocks.org/4063663\">Mike Bostock's d3 Brushable Scatterplot</a>")),
sidebarPanel(
"This example explores the relationship of various Vanguard Funds representing different exposures.  Using Mike Bostock's
interactive d3 scatterplot example, we can more thorougly discover the relationships between these funds.  Try it out by highlighting
portions of the scatterplot.  To remove the selection just click outside of the selection box.",
helpText(HTML("<br></br>Prices provided by Yahoo!Finance.<br></br>All source available on <a href = \"https://github.com/timelyportfolio/shiny-d3-scatterplot\">Github</a>"))
),
mainPanel(
includeHTML("scatterplot.js"),
reactiveSvg(outputId = "scatterplot")
)
)
)
shiny::runApp('//file/UsersY$/yzh215/Home/Desktop/InteractiveMap/Design/1')
shiny::runApp('//file/UsersY$/yzh215/Home/Desktop/InteractiveMap/Design/1/useR13_bivand_tut/citi-bike-data-with-rCharts-master')
## server.r
library(shiny)
require(rCharts)
citibike_all <- read.csv("all-data.csv", header = TRUE, sep = ",")
citibike_all$miles <- round(citibike_all$milesToday, digits=0)
fit1 <- lm(miles ~ day_of_week + maxtemp + precip + cloudsNum + MinDewpointF + maxwind, data=citibike_all)
citibike_all$fit <- as.numeric(fitted(fit1))
#Shiny server function, inputs from slider and dropdown menu, outputs to ui.R or html
shinyServer(function(input, output) {
#########     BEGIN REACTIVE EXPRESIONS    ############
plotBy <- reactive({
paste("miles ~ ", input$variable)
})
groupBy <- reactive({
groups <- switch(input$group,
"rain" = rain,
"sky" = sky,
"day_of_week" = day_of_week,
"month" = month)
})
corNum  <- reactive({
yChoice = input$variable
yCor = citibike_all[yChoice]
round(cor(citibike_all$miles,yCor,method="pearson"),2)
})
corText  <- reactive({
paste("Correlation between miles and  ", input$variable,":")
})
#########     END REACTIVE EXPRESIONS    ############
#########     BEGIN OUTPUTS    ############
output$mainPlot <- renderChart2({
groups <- input$group
yPlot <- input$variable
h1 <- hPlot(as.formula(plotBy()), data = citibike_all, group=groups,name='date',type = 'scatter', radius = 8,
group.na = "Not Available")
h1$params$width = 1000
h1$params$height = 700
h1$yAxis(title = list(text = "Miles travelled"))
# h1$legend(symbolWidth = 80)
h1$tooltip(formatter = "#! function(d) { return '<p>' + this.series.name +'<br>Miles travelled: '     + this.point.y +
'<br>x: '  + this.point.x + '</p>'  ; } !#")
#h1$tooltip(valuePrefix = paste(yPlot," "), crosshairs=list(width=1,color='gray'))
return(h1)
})
output$corNum <- renderText({
corNum()
})
output$corText <- renderText({
corText()
})
#########     END OUTPUTS    ############
})
shiny::runApp('//file/UsersY$/yzh215/Home/Desktop/InteractiveMap/Design/1/useR13_bivand_tut/citi-bike-data-with-rCharts-master')
library(googleVis)
library(shiny)
runGist(4970975)
library(googleVis)
library(shiny)
# Define UI for iris application
ui <- pageWithSidebar(
headerPanel("Example 1: scatter chart"),
sidebarPanel(
selectInput("dataset", "Choose a dataset:",
choices = c("rock", "pressure", "cars"))
),
mainPanel(
htmlOutput("view")
)
)
server <- function(input, output, session) {
# Contributed by Joe Cheng, February 2013
# Requires googleVis version 0.4.0 and shiny 0.4.0 or higher
# server.R
datasetInput <- reactive({
switch(input$dataset,
"rock" = rock,
"pressure" = pressure,
"cars" = cars)
})
output$view <- renderGvis({
gvisScatterChart(datasetInput(), options=list(width=400, height=450))
})
}
shinyApp(ui = ui, server = server)
travelMeans <- c('02', '04')
# LAST UPDATED AT 21/1, 13.00
#
# NEXT TO DO: LINE
# Clearing up the data
# rm(list=ls())
# Loading the requiring sources
require("classInt") || install.packages("classInt")
require("colorRamps") || install.packages("colorRamps")
require("maptools") || install.packages("maptools")
require("stringr") || install.packages("stringr")
# Initializing the variables
travelMean <- c()
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap")
# Reading required data
# geodata contains various travel means and the number of people travel in the means
geodata <- read.csv('geodata.csv'
, col.names= c('AreaCode','AreaName','AreaFull','MeanCode','MeanName','MeanFull','Ppl')
, header= FALSE
, sep = ','
, numerals = c('no.loss'))
# Remove the header from the data - cannot set "header = TRUE" in previous section because it
# would trim the 0s away from Mean codes and Area codes.
geodata <- geodata[!(geodata$MeanCode == 'MeanCode' & geodata$AreaCode == 'AreaCode'), ]
# Generating the details of travel means
meandata <- unique(geodata[c('MeanCode', 'MeanName', 'MeanFull') ] )
meandata <- meandata[order(meandata$MeanName),]
# Generating the list of choices for the Travel means input in UI
meanChoices <- as.character(meandata$MeanCode)
names(meanChoices) <- meandata$MeanName
# Create a new column "Percentage" in geodata
geodata$Percentage <- c(0)
# Create a list with the Areas and the total numbers of ppl
totalList <- setNames(aggregate(as.numeric(levels(geodata$Ppl)[geodata$Ppl]), by=list(Area=geodata$AreaCode), FUN = sum)
, c('AreaCode', 'Total')
)
#Calculate the percentages within Areas
for (i in 1:nrow(geodata))
{
rowPpl <- as.numeric(levels(geodata$Ppl[i])[geodata$Ppl[i]])
rowTotal <- ((totalList[totalList$AreaCode == geodata$AreaCode[i],]) $Total)
geodata$Percentage[i] <- (rowPpl / rowTotal)
}
# Reading and merging the shapefiles
shape <- readShapeSpatial("./Shapefiles/TA2013_GV_Clipped.shp")
shape <- shape[!(shape@data$TA2013_NAM == 'Chatham Islands Territory' | shape@data$TA2013_NAM == 'Area Outside Territorial Authority'),]
shape@data <- merge(shape@data,geodata,by.x="TA2013",by.y="AreaCode", all.x= TRUE )#, replace = TRUE
shape@data$Ppl <- as.numeric(levels(shape@data$Ppl)[shape@data$Ppl])
shape@data$Percentage[is.na(shape@data$Percentage)] <- 0
shape@data$Percentage <- round(shape@data$Percentage*100,4)
# Generating the base of the singleTable (table for single travel mean) in UI
newtable <- subset(shape@data)
newtable <- subset(newtable, select = -c(TA2013, TA2013_NAM, MeanFull, AreaFull))
# This function plots the colored map of single travel mean
singleMap <- function(numQUan, travelMean, classIntMethod)
{
# Defining the color data for single table
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 2)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 2)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 2)
}
colPal <- findColours(nclass, pal(length(nclass$brks)-1))
#Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:length(nclass$brks))
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 2), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(length(nclass$brks)-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(length(nclass$brks)-1), bty = 'o')#, pch= 1
}
prepareTwoMeans <- function(travelMeans) {
listx <- subset(newtable[newtable$MeanCode==travelMeans[1],])
listx <- listx[order(listx$Percentage),]
listy <- subset(newtable[newtable$MeanCode==travelMeans[2],], select = -c(MeanName))
listy <- listy[order(listy$Percentage),]
listx$xpos <- seq(nrow(listx))
listy$ypos <- seq(nrow(listy))
listx <- merge(listx, listy, by.x = c("AreaName"), by.y = c("AreaName"), all=TRUE)
listx <- within(listx, mix <- rgb(red=listx$x, green=0, blue=listx$y, maxColorValue=nrow(listx)))
return(listx)
}
# This function plots the colored map of two travel means
biMap <- function(travelMeans)
{
fullList <- prepareTwoMeans(travelMeans)
for (n in 1:nrow(fullList)) {
fullList$r[n] <- col2rgb(fullList$mix[n])[,1][1]
fullList$g[n] <- col2rgb(fullList$mix[n])[,1][2]
fullList$b[n] <- col2rgb(fullList$mix[n])[,1][3]
}
fullList[order(fullList$xpos,fullList$ypos),]
plot(shape, legend=FALSE, border = "Black", col= fullList$mix)
}
#singleMap(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
# LAST UPDATED AT 21/1, 13.00
#
# NEXT TO DO: LINE
# Loading the requiring sources
require("devtools") || install.packages("devtools")
require("scatterD3") || install.packages("scatterD3")
library(scatterD3)
#devtools::install_github("juba/scatterD3")
require("shiny") || install.packages("shiny")
require("DT") || install.packages("DT")
# defining a function
#is.installed <- function(mypkg) is.element(mypkg, installed.packages()[,1])
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap/Shiny")
source("helper.R")
# Initializing the variables
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
titlePanel(title = "Interactive Map of New Zealand", windowTitle = "Interactive Map of New Zealand"),
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, br()
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
, multiple = FALSE
)
, br()
# The following part is groupCheckBox format for the travelMeans
, checkboxGroupInput(
"travelMeans"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
)
, br()
),
#Show the map
mainPanel(
tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", DT::dataTableOutput("onetable"), hr())
, tabPanel("Single-Mean Plot", plotOutput("oneMap", width = "1200px", height = "800px"))
, tabPanel("Scatterplot", scatterD3Output("biScatter", width = "100%", height = "600px"))
, tabPanel("Two-Mean Plot", plotOutput("biMap", width = "1200px", height = "800px")
, verbatimTextOutput("biMapText"))
)
, position="center"
, height= "auto"
)
)
#Definte server logic required to draw the map
server <- function(input, output, session) {
updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMeans, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
row.names(onetable) <- seq(length = nrow(onetable))
return (onetable)
})
output$onetable <- DT::renderDataTable({
DT::datatable(
updateoneTable(), selection = "none"
, extensions = list("Scroller")
, options = list(
scrollY = 700
, pageLength = 30
, lengthMenu = list(c(30, -1), c("30", "All"))
)
)}
, server = TRUE
)
observe({
if (length(input$travelMeans) > maxGrp)
{
updateCheckboxGroupInput(session, 'travelMeans', selected = tail(input$travelMeans,maxGrp))
}
})
output$biMapText <- renderText({
paste("Red: ", meandata$MeanName[meandata$MeanCode == input$travelMeans[1]]
, "Purple: A combination of both travel means"
, "Blue: ", meandata$MeanName[meandata$MeanCode == input$travelMeans[2]], sep = "\n")
})
output$oneMap <- renderPlot(singleMap(input$categories, input$travelMeans, input$classIntMethod))
output$biMap  <- renderPlot(biMap(input$travelMeans))
biList <- reactive({
prepareTwoMeans(input$travelMeans)
})
output$biScatter <- renderScatterD3({
tooltips <- paste("<strong>Territory Authority: ", biList()$AreaName,"</strong><br /> Percentage of x: "
, biList()$Percentage.x, "<br />"
, "Percentage of y: ", biList()$Percentage.y)
plot <- scatterD3(x = biList()$Percentage.x, y = biList()$Percentage.y
, xlab = meandata$MeanName[meandata$MeanCode == unique(biList()$MeanCode.x)]
, ylab = meandata$MeanName[meandata$MeanCode == unique(biList()$MeanCode.y)]
, tooltip_text = tooltips
)
return (plot)
})
}
shinyApp(ui = ui, server = server)
require("shiny") || install.packages("shiny")
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap/Shiny")
source("helper.R")
# Initializing the variables
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
titlePanel(title = "Interactive Map of New Zealand", windowTitle = "Interactive Map of New Zealand"),
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, br()
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
, multiple = FALSE
)
, br()
# The following part is groupCheckBox format for the travelMeans
, checkboxGroupInput(
"travelMeans"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
)
, br()
),
#Show the map
mainPanel(
tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", DT::dataTableOutput("onetable"), hr())
, tabPanel("Single-Mean Plot", plotOutput("oneMap", width = "1200px", height = "800px"))
, tabPanel("Scatterplot", scatterD3Output("biScatter", width = "100%", height = "600px"))
, tabPanel("Two-Mean Plot", plotOutput("biMap", width = "1200px", height = "800px")
, verbatimTextOutput("biMapText"))
)
, position="center"
, height= "auto"
)
)
require("shiny") || install.packages("shiny")
install.packages("shiny")
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap/Shiny")
source("helper.R")
# Initializing the variables
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
titlePanel(title = "Interactive Map of New Zealand", windowTitle = "Interactive Map of New Zealand"),
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, br()
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
, multiple = FALSE
)
, br()
# The following part is groupCheckBox format for the travelMeans
, checkboxGroupInput(
"travelMeans"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
)
, br()
),
#Show the map
mainPanel(
tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", DT::dataTableOutput("onetable"), hr())
, tabPanel("Single-Mean Plot", plotOutput("oneMap", width = "1200px", height = "800px"))
, tabPanel("Scatterplot", scatterD3Output("biScatter", width = "100%", height = "600px"))
, tabPanel("Two-Mean Plot", plotOutput("biMap", width = "1200px", height = "800px")
, verbatimTextOutput("biMapText"))
)
, position="center"
, height= "auto"
)
)
library(shiny)
update.packages("htmltools")
library(shiny)
library("htmltools", lib.loc="\\\\file/UsersY$/yzh215/Home/My Documents/R/win-library/3.2")
update.packages("DT")
update.packages("htmltools")
library(scatterD3)
library(shiny)
if (!require("devtools"))
install.packages("devtools")
devtools::install_github("rstudio/shiny")
