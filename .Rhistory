updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMean, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
})
output$onetable <- renderTable({
updateoneTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", tail(input$travelMean, 1))
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
#, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight')
)
#test <- reactive({ length(input$travelMean)})
#test1 <- reactive({ input$travelMean})
test <- reactive({summary(input$travelMean) })
test
observe({
if (length(input$travelMean) > maxGrp)
{
updateCheckboxInput(session, 'travelMean', selected = tail(input$travelMean,maxGrp))
}
#
#       if (length(input$travelMean) < minGrp)
#       {
#         updateCheckboxGroupInput(session, 'travelMean', selected = as.character(meandata$MeanCode[1]))
#       }
})
updatebiTable <- reactive({
biTable <- subset(newtable, newtable$MeanCode == input$travelMean, select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
biTable <- biTable[order(biTable$Percentage),]
})
output$biTable <- renderTable({
updatebiTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", input$travelMean, 1)
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
)
output$text1 <- renderText({paste("Travel mean: ", input$travelMean, collapse = ',')})
#output$text1 <- renderText({paste("Travel mean: ", input$travelMean)})
output$text2 <- renderText({paste("Selected ", input$categories, " categories")})
output$oneMap <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
output$biMap  <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
}
shinyApp(ui = ui, server = server)
debugSource('//file/UsersY$/yzh215/Home/Desktop/GitHub/InteractiveMap/Shiny/combined.R')
library(shiny)
library(DT)
setwd("//file/UsersY$/yzh215/Home/Desktop/GitHub/InteractiveMap/Shiny")
source("helper.R")
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
#                        , selectize = FALSE
, multiple = FALSE
#                        , width = "auto"
)
, br()
# The following part is SelectInput format for the TravelMean
#         selectInput("travelMean", "Travel Mean"
#                       , label = "Select the mean below:"
#                       , choices = meanChoices
#                       , multiple = TRUE
#                       , width = "100%"
#         )
# The following part is groupCheckBox format for the TravelMean
, checkboxGroupInput(
"travelMean"
#                    , "Travel Mean"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
#, inline = FALSE
)
, br()
, height = "10%"
),
#Show the map
mainPanel(
h3("Map of New Zealand", align = "center")
, h4(textOutput("text1"), align = "center")
, h4(textOutput("text2"), align = "center")
, h4("Data is in percentages", align = "center")
, tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", tableOutput("onetable")  )
, tabPanel("Single-Mean Plot", plotOutput("oneMap"))
, tabPanel("Two-Mean Table", tableOutput("biTable")  )
, tabPanel("Two-Mean Plot", plotOutput("biMap"))
)
, position="center"
, width= "auto"
, height= "auto"
)
)
#Definte server logic required to draw the map
server <- function(input, output, session) {
updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMean, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
})
output$onetable <- renderTable({
updateoneTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", tail(input$travelMean, 1))
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
#, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight')
)
#test <- reactive({ length(input$travelMean)})
#test1 <- reactive({ input$travelMean})
test <- reactive({summary(input$travelMean) })
test
observe({
if (length(input$travelMean) > maxGrp)
{
updateCheckboxInput(session, 'travelMean', selected = tail(input$travelMean,maxGrp))
}
#
#       if (length(input$travelMean) < minGrp)
#       {
#         updateCheckboxGroupInput(session, 'travelMean', selected = as.character(meandata$MeanCode[1]))
#       }
})
updatebiTable <- reactive({
biTable <- subset(newtable, newtable$MeanCode == input$travelMean, select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
biTable <- biTable[order(biTable$Percentage),]
})
output$biTable <- renderTable({
updatebiTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", input$travelMean, 1)
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
)
output$text1 <- renderText({paste("Travel mean: ", input$travelMean, collapse = ',')})
#output$text1 <- renderText({paste("Travel mean: ", input$travelMean)})
output$text2 <- renderText({paste("Selected ", input$categories, " categories")})
output$oneMap <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
output$biMap  <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
}
shinyApp(ui = ui, server = server)
library(shiny)
library(DT)
setwd("//file/UsersY$/yzh215/Home/Desktop/GitHub/InteractiveMap/Shiny")
source("helper.R")
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
#                        , selectize = FALSE
, multiple = FALSE
#                        , width = "auto"
)
, br()
# The following part is SelectInput format for the TravelMean
#         selectInput("travelMean", "Travel Mean"
#                       , label = "Select the mean below:"
#                       , choices = meanChoices
#                       , multiple = TRUE
#                       , width = "100%"
#         )
# The following part is groupCheckBox format for the TravelMean
, checkboxGroupInput(
"travelMean"
#                    , "Travel Mean"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
#, inline = FALSE
)
, br()
, height = "10%"
),
#Show the map
mainPanel(
h3("Map of New Zealand", align = "center")
, h4(textOutput("text1"), align = "center")
, h4(textOutput("text2"), align = "center")
, h4("Data is in percentages", align = "center")
, tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", tableOutput("onetable")  )
, tabPanel("Single-Mean Plot", plotOutput("oneMap"))
, tabPanel("Two-Mean Table", tableOutput("biTable")  )
, tabPanel("Two-Mean Plot", plotOutput("biMap"))
)
, position="center"
, width= "auto"
, height= "auto"
)
)
#Definte server logic required to draw the map
server <- function(input, output, session) {
updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMean, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
})
output$onetable <- renderTable({
updateoneTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", tail(input$travelMean, 1))
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
#, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight')
)
#test <- reactive({ length(input$travelMean)})
#test1 <- reactive({ input$travelMean})
test <- reactive({summary(input$travelMean) })
test
observe({
if (length(input$travelMean) > maxGrp)
{
updateCheckboxGroupInput(session, 'travelMean', selected = tail(input$travelMean,maxGrp))
}
#
#       if (length(input$travelMean) < minGrp)
#       {
#         updateCheckboxGroupInput(session, 'travelMean', selected = as.character(meandata$MeanCode[1]))
#       }
})
updatebiTable <- reactive({
biTable <- subset(newtable, newtable$MeanCode == input$travelMean, select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
biTable <- biTable[order(biTable$Percentage),]
})
output$biTable <- renderTable({
updatebiTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", input$travelMean, 1)
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
)
output$text1 <- renderText({paste("Travel mean: ", input$travelMean, collapse = ',')})
#output$text1 <- renderText({paste("Travel mean: ", input$travelMean)})
output$text2 <- renderText({paste("Selected ", input$categories, " categories")})
output$oneMap <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
output$biMap  <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
}
shinyApp(ui = ui, server = server)
tail(freeny.y)
head(freeny.y)
head(freeny.y,2)
shinyApp(ui = ui, server = server)
# This script is used for testing new method
bike <- subset(geodata[(geodata$MeanCode %in% c('09', '02')#, '15')
#  & geodata$AreaCode %in% c('001', '002', '003')
),]
, select=-c(AreaName, AreaFull, MeanFull,MeanName, Percentage))
bike
data.frame(1, 1:10, sample(L3, 10, replace = TRUE))
L3 <- LETTERS[1:3]
fac <- sample(L3, 10, replace = TRUE)
(d <- data.frame(x = 1, y = 1:10, fac = fac))
## The "same" with automatic column names:
data.frame(1, 1:10, sample(L3, 10, replace = TRUE))
meandata
bike$MeanCode[1]
new <- data.frame(row.names = bike$MeanCode[1], col.names = bike$MeanCode[2])
new
names(new)
summary
summary(new)
new <- data.frame(row.names = bike$MeanCode[1], bike$MeanCode[2])
new
as.matrix(bike)
bike
test <- matrix(c(bike$Ppl), nrow = length(bike$AreaCode), ncol = length(bike$AreaCode)
,byrow = TRUE, dimnames = list(c(bike$AreaCode), c(bike$MeanCode)))
test
test <- matrix(c(bike$Ppl[1:10,]), nrow = length(bike$AreaCode), ncol = length(bike$AreaCode)
,byrow = TRUE, dimnames = list(c(bike$AreaCode), c(bike$MeanCode)))
bike <- bike[1:10,]
bike
test <- matrix(c(bike$Ppl), nrow = length(bike$AreaCode), ncol = length(bike$AreaCode)
,byrow = TRUE, dimnames = list(c(bike$AreaCode), c(bike$MeanCode)))
test
test <- matrix(c(bike$Ppl), nrow = length(bike$AreaCode), ncol = length(bike$AreaCode)
,byrow = TRUE, dimnames = list(bike$AreaCode, bike$MeanCode))
test
bike
test
bike
CrossTable(bike$AreaCode, bike$MeanCode)
library(gmodels)
CrossTable(bike$AreaCode, bike$MeanCode)
xtab(AreaCode~MeanCode, bike)
bike
bike <- subset(geodata[(geodata$MeanCode %in% c('09', '02')#, '15')
#  & geodata$AreaCode %in% c('001', '002', '003')
),]
bike <- subset(geodata[(geodata$MeanCode %in% c('09', '02')#, '15')
#  & geodata$AreaCode %in% c('001', '002', '003')
),]
, select=-c(AreaName, AreaFull, MeanFull,MeanName, Percentage))
bike <- subset(geodata[(geodata$MeanCode %in% c('09', '02')#, '15')
#  & geodata$AreaCode %in% c('001', '002', '003')
),]
, select=-c(AreaName, AreaFull, MeanFull,MeanName, Percentage))
bike
head(bike)
pal <- colorRampPalette(c("blue", "red"), space="rgb")
library(lattice)
library(lattice)
bike
head(bike)
nrowcol <- length(bike)
nrowcol
bike
as.matrix(bike)
bike.b >- as.matrix(bike)
bike.b
bike.b <- as.matrix(bike)
bike.b
ac <- c(bike$AreaCode)
mc <- c(bike$MeanCode)
pc <- c(bike$Ppl)
ac
c(bike$AreaCode)
c(bike$MeanCode)
bike$MeanCode
mc <- bike$MeanCode
mc
ac <- bike$AreaCode
mc <- bike$MeanCode
pc <- bike$Ppl
ac, mc, pc
matrix.b <- cbine(ac,mc,pc)
matrix.b
matrix.b <- cbind(ac,mc,pc)
matrix.b
head(matrix.b)
library(lattice)
bike
nrowcol <- length(bike)
nrowcol
cor <- matrix(runif(nrowcol*nrowcol, min(bike$Ppl), nrow=nrowcol, ncol=nrowcol, dimnames=list(AreaCode, MeanCode)))
min(bike$Ppl)
bike$Ppl
min(bike$Ppl)
cor <- matrix(runif(nrowcol*nrowcol, min=min(bike$Ppl), nrow=nrowcol, ncol=nrowcol, dimnames=list(AreaCode, MeanCode)))
cor <- matrix(runif(nrowcol*nrowcol, min=min(bike$Ppl)), nrow=nrowcol, ncol=nrowcol, dimnames = list(AreaCode, MeanCode))
min(bike$Ppl)
cor <- matrix(runif(nrowcol*nrowcol, min=c(min(bike$Ppl)), nrow=nrowcol, ncol=nrowcol, dimnames = list(AreaCode, MeanCode))
cor <- matrix(runif(nrowcol*nrowcol, min=c(min(bike$Ppl))), nrow=nrowcol, ncol=nrowcol, dimnames = list(AreaCode, MeanCode))
runif(nrowcol*nrowcol, min=c(min(bike$Ppl)))
#Loading the requiring sources
library(maptools)
library(classInt)
library(stringr)
library(colorRamps)
runif(nrowcol*nrowcol, min=c(min(bike$Ppl)))
bike$Ppl
cor <- matrix(runif(nrowcol*nrowcol, min=c(as.numeric(bike$Ppl))), nrow=nrowcol, ncol=nrowcol, dimnames = list(AreaCode, MeanCode))
cor <- matrix(runif(nrowcol*nrowcol, min=c(as.numeric(bike$Ppl))), nrow=nrowcol, ncol=nrowcol, dimnames = list(AreaCode, MeanCode))
list(AreaCode, MeanCode)
cor <- matrix(runif(nrowcol*nrowcol, min=c(as.numeric(bike$Ppl))), nrow=nrowcol, ncol=nrowcol, dimnames = list(bike$AreaCode, bike$MeanCode))
list(bike$AreaCode, bike$MeanCode)
cor <- matrix(runif(nrowcol*nrowcol, min=c(as.numeric(bike$Ppl))), nrow=nrowcol, ncol=nrowcol, dimnames = list(bike$AreaCode, bike$MeanCode))
, options = list(paging = FALSE, searching = FALSE)
library(shiny)
library(DT)
setwd("//file/UsersY$/yzh215/Home/Desktop/GitHub/InteractiveMap/Shiny")
source("helper.R")
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- fluidPage(
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fisher" = "fisher"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
#                        , selectize = FALSE
, multiple = FALSE
#                        , width = "auto"
)
, br()
# The following part is SelectInput format for the TravelMean
#         selectInput("travelMean", "Travel Mean"
#                       , label = "Select the mean below:"
#                       , choices = meanChoices
#                       , multiple = TRUE
#                       , width = "100%"
#         )
# The following part is groupCheckBox format for the TravelMean
, checkboxGroupInput(
"travelMean"
#                    , "Travel Mean"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
#, inline = FALSE
)
, br()
, height = "10%"
),
#Show the map
mainPanel(
h3("Map of New Zealand", align = "center")
, h4(textOutput("text1"), align = "center")
, h4(textOutput("text2"), align = "center")
, h4("Data is in percentages", align = "center")
, tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", tableOutput("onetable")  )
, tabPanel("Single-Mean Plot", plotOutput("oneMap"))
, tabPanel("Two-Mean Table", tableOutput("biTable")  )
, tabPanel("Two-Mean Plot", plotOutput("biMap"))
)
, position="center"
, width= "auto"
, height= "auto"
)
)
#Definte server logic required to draw the map
server <- function(input, output, session) {
updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMean, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
})
output$onetable <- renderTable({
updateoneTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", tail(input$travelMean, 1))
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
#, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight')
)
#test <- reactive({ length(input$travelMean)})
#test1 <- reactive({ input$travelMean})
test <- reactive({summary(input$travelMean) })
test
observe({
if (length(input$travelMean) > maxGrp)
{
updateCheckboxGroupInput(session, 'travelMean', selected = tail(input$travelMean,maxGrp))
}
#
#       if (length(input$travelMean) < minGrp)
#       {
#         updateCheckboxGroupInput(session, 'travelMean', selected = as.character(meandata$MeanCode[1]))
#       }
})
updatebiTable <- reactive({
biTable <- subset(newtable, newtable$MeanCode == input$travelMean, select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
biTable <- biTable[order(biTable$Percentage),]
})
output$biTable <- renderTable({
updatebiTable()}
, include.rownames = FALSE
, options = list(paging = FALSE, searching = FALSE)
, caption = paste("Travel mean: ", input$travelMean, 1)
, caption.placement = getOption("xtable.caption.placement", "top")
, caption.width = getOption("xtable.caption.width", NULL)
)
output$text1 <- renderText({paste("Travel mean: ", input$travelMean, collapse = ',')})
#output$text1 <- renderText({paste("Travel mean: ", input$travelMean)})
output$text2 <- renderText({paste("Selected ", input$categories, " categories")})
output$oneMap <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
output$biMap  <- renderPlot(nz_map(input$categories, input$travelMean, input$classIntMethod))
}
shinyApp(ui = ui, server = server)
