yLabels <- c(1:nrow(x))
}
layout(matrix(data=c(1,2), nrow=1, ncol=2), widths=c(4,1), heights=c(1,1))
# Red and green range from 0 to 1 while Blue ranges from 1 to 0
ColorRamp <- rgb( seq(0,1,length=256),  # Red
seq(0,1,length=256),  # Green
seq(1,0,length=256))  # Blue
ColorLevels <- seq(min, max, length=length(ColorRamp))
# Reverse Y axis
reverse <- nrow(x) : 1
yLabels <- yLabels[reverse]
x <- x[reverse,]
# Data Map
par(mar = c(3,5,2.5,2))
image(1:length(xLabels), 1:length(yLabels), t(x), col=ColorRamp, xlab="",
ylab="", axes=FALSE, zlim=c(min,max))
if( !is.null(title) ){
title(main=title)
}
axis(BELOW<-1, at=1:length(xLabels), labels=xLabels, cex.axis=0.7)
axis(LEFT <-2, at=1:length(yLabels), labels=yLabels, las= HORIZONTAL<-1,
cex.axis=0.7)
# Color Scale
par(mar = c(3,2.5,2.5,2))
image(1, ColorLevels,
matrix(data=ColorLevels, ncol=length(ColorLevels),nrow=1),
col=ColorRamp,
xlab="",ylab="",
xaxt="n")
layout(1)
# LAST UPDATED AT 21/1, 13.00
#
# NEXT TO DO: LINE
# Clearing up the data
# rm(list=ls())
# Loading the requiring sources
require("classInt") || install.packages("classInt")
require("colorRamps") || install.packages("colorRamps")
require("maptools") || install.packages("maptools")
require("stringr") || install.packages("stringr")
# Initializing the variables
travelMean <- c()
# Set the working directory and read the required data
# setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
setwd("C:/Users/User/Desktop/InteractiveMap")
# Reading required data
# geodata contains various travel means and the number of people travel in the means
geodata <- read.csv('geodata.csv'
, col.names= c('AreaCode','AreaName','AreaFull','MeanCode','MeanName','MeanFull','Ppl')
, header= FALSE
, sep = ','
, numerals = c('no.loss'))
# Remove the header from the data - cannot set "header = TRUE" in previous section because it
# would trim the 0s away from Mean codes and Area codes.
geodata <- geodata[!(geodata$MeanCode == 'MeanCode' & geodata$AreaCode == 'AreaCode'), ]
# Generating the details of travel means
meandata <- unique(geodata[c('MeanCode', 'MeanName', 'MeanFull') ] )
meandata <- meandata[order(meandata$MeanName),]
# Generating the list of choices for the Travel means input in UI
meanChoices <- as.character(meandata$MeanCode)
names(meanChoices) <- meandata$MeanName
# Create a new column "Percentage" in geodata
geodata$Percentage <- c(0)
# Create a list with the Areas and the total numbers of ppl
totalList <- setNames(aggregate(as.numeric(levels(geodata$Ppl)[geodata$Ppl]), by=list(Area=geodata$AreaCode), FUN = sum)
, c('AreaCode', 'Total')
)
# Calculate the percentages within Areas
for (i in 1:nrow(geodata))
{
rowPpl <- as.numeric(levels(geodata$Ppl[i])[geodata$Ppl[i]])
rowTotal <- ((totalList[totalList$AreaCode == geodata$AreaCode[i],]) $Total)
geodata$Percentage[i] <- (rowPpl / rowTotal)
}
# Reading and merging the shapefiles
shape <- readShapeSpatial("./Shapefiles/TA2013_GV_Clipped.shp")
shape <- shape[!(shape@data$TA2013_NAM == 'Chatham Islands Territory' | shape@data$TA2013_NAM == 'Area Outside Territorial Authority'),]
shape@data <- merge(shape@data,geodata,by.x="TA2013",by.y="AreaCode", all.x= TRUE )#, replace = TRUE
shape@data$Ppl <- as.numeric(levels(shape@data$Ppl)[shape@data$Ppl])
shape@data$Percentage[is.na(shape@data$Percentage)] <- 0
shape@data$Percentage <- round(shape@data$Percentage*100,1)
# Generating the base of the singleTable (table for single travel mean) in UI
newtable <- subset(shape@data)
newtable <- subset(newtable, select = -c(TA2013, TA2013_NAM, MeanFull, AreaFull))
# This function plots the colored map of single travel mean
singleMap <- function(numQUan, travelMean, classIntMethod)
{
# Defining the color data for single table
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 1)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 1)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 1)
}
len <- length(nclass$brks)
colPal <- findColours(nclass, pal(len))
# Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:len)
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 1), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(len-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
#legend('bottomright', legend= nclass$brk, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
}
prepareTwoMeans <- function(travelMeans) {
listx <- subset(newtable[newtable$MeanCode==travelMeans[1],])
listx <- listx[order(listx$Percentage),]
listy <- subset(newtable[newtable$MeanCode==travelMeans[2],], select = -c(MeanName))
listy <- listy[order(listy$Percentage),]
listx$xpos <- seq(nrow(listx))
listy$ypos <- seq(nrow(listy))
listx <- merge(listx, listy, by.x = c("AreaName"), by.y = c("AreaName"), all=TRUE)
listx <- within(listx, mix <- rgb(red=255*listx$x/nrow(listx), green=0, blue=255*listx$y/nrow(listx)
, maxColorValue=255))
return(listx)
}
# This function plots the colored map of two travel means
biMap <- function(travelMeans)
{
fullList <- prepareTwoMeans(travelMeans)
plot(shape, legend=FALSE, border = "Black", col= fullList$mix)
#legend('bottomright', legend = "x,y", title = 'Legend', fill= pal(fullList$mix), bty = 'o')#, pch= 1
}
#singleMap(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
# LAST UPDATED AT 21/1, 13.00
#
# NEXT TO DO: LINE
# Clearing up the data
# rm(list=ls())
# Loading the requiring sources
require("classInt") || install.packages("classInt")
require("colorRamps") || install.packages("colorRamps")
require("maptools") || install.packages("maptools")
require("stringr") || install.packages("stringr")
# Initializing the variables
travelMean <- c()
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap")
# Reading required data
# geodata contains various travel means and the number of people travel in the means
geodata <- read.csv('geodata.csv'
, col.names= c('AreaCode','AreaName','AreaFull','MeanCode','MeanName','MeanFull','Ppl')
, header= FALSE
, sep = ','
, numerals = c('no.loss'))
# Remove the header from the data - cannot set "header = TRUE" in previous section because it
# would trim the 0s away from Mean codes and Area codes.
geodata <- geodata[!(geodata$MeanCode == 'MeanCode' & geodata$AreaCode == 'AreaCode'), ]
# Generating the details of travel means
meandata <- unique(geodata[c('MeanCode', 'MeanName', 'MeanFull') ] )
meandata <- meandata[order(meandata$MeanName),]
# Generating the list of choices for the Travel means input in UI
meanChoices <- as.character(meandata$MeanCode)
names(meanChoices) <- meandata$MeanName
# Create a new column "Percentage" in geodata
geodata$Percentage <- c(0)
# Create a list with the Areas and the total numbers of ppl
totalList <- setNames(aggregate(as.numeric(levels(geodata$Ppl)[geodata$Ppl]), by=list(Area=geodata$AreaCode), FUN = sum)
, c('AreaCode', 'Total')
)
# Calculate the percentages within Areas
for (i in 1:nrow(geodata))
{
rowPpl <- as.numeric(levels(geodata$Ppl[i])[geodata$Ppl[i]])
rowTotal <- ((totalList[totalList$AreaCode == geodata$AreaCode[i],]) $Total)
geodata$Percentage[i] <- (rowPpl / rowTotal)
}
# Reading and merging the shapefiles
shape <- readShapeSpatial("./Shapefiles/TA2013_GV_Clipped.shp")
shape <- shape[!(shape@data$TA2013_NAM == 'Chatham Islands Territory' | shape@data$TA2013_NAM == 'Area Outside Territorial Authority'),]
shape@data <- merge(shape@data,geodata,by.x="TA2013",by.y="AreaCode", all.x= TRUE )#, replace = TRUE
shape@data$Ppl <- as.numeric(levels(shape@data$Ppl)[shape@data$Ppl])
shape@data$Percentage[is.na(shape@data$Percentage)] <- 0
shape@data$Percentage <- round(shape@data$Percentage*100,1)
# Generating the base of the singleTable (table for single travel mean) in UI
newtable <- subset(shape@data)
newtable <- subset(newtable, select = -c(TA2013, TA2013_NAM, MeanFull, AreaFull))
# This function plots the colored map of single travel mean
singleMap <- function(numQUan, travelMean, classIntMethod)
{
# Defining the color data for single table
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 1)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 1)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 1)
}
len <- length(nclass$brks)
colPal <- findColours(nclass, pal(len))
# Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:len)
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 1), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(len-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
#legend('bottomright', legend= nclass$brk, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
}
prepareTwoMeans <- function(travelMeans) {
listx <- subset(newtable[newtable$MeanCode==travelMeans[1],])
listx <- listx[order(listx$Percentage),]
listy <- subset(newtable[newtable$MeanCode==travelMeans[2],], select = -c(MeanName))
listy <- listy[order(listy$Percentage),]
listx$xpos <- seq(nrow(listx))
listy$ypos <- seq(nrow(listy))
listx <- merge(listx, listy, by.x = c("AreaName"), by.y = c("AreaName"), all=TRUE)
listx <- within(listx, mix <- rgb(red=255*listx$x/nrow(listx), green=0, blue=255*listx$y/nrow(listx)
, maxColorValue=255))
return(listx)
}
# This function plots the colored map of two travel means
biMap <- function(travelMeans)
{
fullList <- prepareTwoMeans(travelMeans)
plot(shape, legend=FALSE, border = "Black", col= fullList$mix)
#legend('bottomright', legend = "x,y", title = 'Legend', fill= pal(fullList$mix), bty = 'o')#, pch= 1
}
#singleMap(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
# LAST UPDATED AT 21/1, 13.00
#
# NEXT TO DO: LINE
# Clearing up the data
# rm(list=ls())
# Loading the requiring sources
require("classInt") || install.packages("classInt")
require("colorRamps") || install.packages("colorRamps")
require("maptools") || install.packages("maptools")
require("stringr") || install.packages("stringr")
# Initializing the variables
travelMean <- c()
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap")
# Reading required data
# geodata contains various travel means and the number of people travel in the means
geodata <- read.csv('geodata.csv'
, col.names= c('AreaCode','AreaName','AreaFull','MeanCode','MeanName','MeanFull','Ppl')
, header= FALSE
, sep = ','
, numerals = c('no.loss'))
# Remove the header from the data - cannot set "header = TRUE" in previous section because it
# would trim the 0s away from Mean codes and Area codes.
geodata <- geodata[!(geodata$MeanCode == 'MeanCode' & geodata$AreaCode == 'AreaCode'), ]
# Generating the details of travel means
meandata <- unique(geodata[c('MeanCode', 'MeanName', 'MeanFull') ] )
meandata <- meandata[order(meandata$MeanName),]
# Generating the list of choices for the Travel means input in UI
meanChoices <- as.character(meandata$MeanCode)
names(meanChoices) <- meandata$MeanName
# Create a new column "Percentage" in geodata
geodata$Percentage <- c(0)
# Create a list with the Areas and the total numbers of ppl
totalList <- setNames(aggregate(as.numeric(levels(geodata$Ppl)[geodata$Ppl]), by=list(Area=geodata$AreaCode), FUN = sum)
, c('AreaCode', 'Total')
)
# Calculate the percentages within Areas
for (i in 1:nrow(geodata))
{
rowPpl <- as.numeric(levels(geodata$Ppl[i])[geodata$Ppl[i]])
rowTotal <- ((totalList[totalList$AreaCode == geodata$AreaCode[i],]) $Total)
geodata$Percentage[i] <- (rowPpl / rowTotal)
}
# Reading and merging the shapefiles
shape <- readShapeSpatial("./Shapefiles/TA2013_GV_Clipped.shp")
shape <- shape[!(shape@data$TA2013_NAM == 'Chatham Islands Territory' | shape@data$TA2013_NAM == 'Area Outside Territorial Authority'),]
shape@data <- merge(shape@data,geodata,by.x="TA2013",by.y="AreaCode", all.x= TRUE )#, replace = TRUE
shape@data$Ppl <- as.numeric(levels(shape@data$Ppl)[shape@data$Ppl])
shape@data$Percentage[is.na(shape@data$Percentage)] <- 0
shape@data$Percentage <- round(shape@data$Percentage*100,1)
# Generating the base of the singleTable (table for single travel mean) in UI
newtable <- subset(shape@data)
newtable <- subset(newtable, select = -c(TA2013, TA2013_NAM, MeanFull, AreaFull))
# This function plots the colored map of single travel mean
singleMap <- function(numQUan, travelMean, classIntMethod)
{
# Defining the color data for single table
pal <- colorRampPalette(c("yellow","red"), space= "rgb")
if (classIntMethod == "fixed") {
breakList <- c(min(shape@data$Percentage[shape@data$Mean==travelMean]))
unit <- round(max(shape@data$Percentage[shape@data$Mean==travelMean])/numQUan, digits = 1)
for (i in 1:numQUan) {
breakList <- c(breakList, unit*i)
}
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, fixedBreaks = breakList, dataPrecision = 1)
} else {
nclass <- classIntervals(shape@data$Percentage[shape@data$MeanCode==travelMean], n= numQUan, style = classIntMethod
, dataPrecision = 1)
}
len <- length(nclass$brks)
colPal <- findColours(nclass, pal(len))
# Draw the coloured map and relevant details
plot(shape, legend=FALSE, border = "Black", col= colPal)
#Setting up the legend text in the proper percentages format
legendT <- c()
legendText <- c()
newText <- c()
for (i in 1:len)
{
newText <- str_trim(paste(round(nclass$brks[i], digits = 1), '%'))
legendT <- c(legendT, newText)
}
for (i in 1:(len-1))
{
newText <- c()
if (i == 1 && classIntMethod != "fixed") {
newText <- paste('0 % -', legendT[i])
}
else {
newText <- paste(legendT[i], '-', legendT[i+1])
}
legendText <- c(legendText, newText)
}
legend('bottomright', legend= legendText, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
#legend('bottomright', legend= nclass$brk, title = 'Legend', fill= pal(len), bty = 'o')#, pch= 1
}
prepareTwoMeans <- function(travelMeans) {
listx <- subset(newtable[newtable$MeanCode==travelMeans[1],])
listx <- listx[order(listx$Percentage),]
listy <- subset(newtable[newtable$MeanCode==travelMeans[2],], select = -c(MeanName))
listy <- listy[order(listy$Percentage),]
listx$xpos <- seq(nrow(listx))
listy$ypos <- seq(nrow(listy))
listx <- merge(listx, listy, by.x = c("AreaName"), by.y = c("AreaName"), all=TRUE)
listx <- within(listx, mix <- rgb(red=255*listx$x/nrow(listx), green=0, blue=255*listx$y/nrow(listx)
, maxColorValue=255))
return(listx)
}
# This function plots the colored map of two travel means
biMap <- function(travelMeans)
{
fullList <- prepareTwoMeans(travelMeans)
plot(shape, legend=FALSE, border = "Black", col= fullList$mix)
#legend('bottomright', legend = "x,y", title = 'Legend', fill= pal(fullList$mix), bty = 'o')#, pch= 1
}
#singleMap(5, travelMean = as.character(meandata$MeanCode[1]), "pretty")
#title(paste ("Map of New Zealand \n Travel mean: ", meandata$MeanName[meandata$MeanCode == travelMean]))
# LAST UPDATED AT 21/1, 13.00
#
# NEXT TO DO: LINE
# defining a function
# is.installed <- function(pkg_list) {
#   if (install.packages(pkg_list))
#is.element(mypkg, installed.packages()[,1])
# }
# update.packages("DT")
# update.packages("htmltools")
if (!require("devtools"))
install.packages("devtools")
# devtools::install_github("rstudio/shiny")
# Loading the requiring sources
require("devtools") || install.packages("devtools")
require("shiny") || install.packages("shiny")
require("DT") || install.packages("DT")
require("scatterD3") || install.packages("scatterD3")
library(scatterD3)
library(shiny)
#devtools::install_github("juba/scatterD3")
# Set the working directory and read the required data
setwd("//file/UsersY$/yzh215/Home/Desktop/InteractiveMap")
# setwd("/home/cococatty/Desktop/InteractiveMap")
# setwd("C:/Users/User/Desktop/InteractiveMap")
source("helper.R")
# Initializing the variables
minGrp <- 1
maxGrp <- 2
#Definte UI for the application
ui <- shinyUI(fluidPage(
titlePanel(title = "Interactive Map of New Zealand", windowTitle = "Interactive Map of New Zealand"),
sidebarPanel(
sliderInput("categories", "Number of Categories", min = 1, max = 10, value = 5
)
, br()
, selectInput(
"classIntMethod"#, "Division Method"
, label = "Select the intervals"
, choices = list("Equal" = "equal"
, "Fixed"= "fixed"
, "Pretty" = "pretty"
, "Quantiles" = "quantile"
, "Standard Deviation" = "sd"
)
, selected = "quantile"
, multiple = FALSE
)
, br()
# The following part is groupCheckBox format for the travelMeans
, checkboxGroupInput(
"travelMeans"
, label = "Select the mean below:"
, choices = meanChoices
, selected = NULL
)
, br()
),
#Show the map
mainPanel(
tabsetPanel(#type = "tabs",
tabPanel("Single-Mean Table", DT::dataTableOutput("onetable"), hr())
, tabPanel("Single-Mean Plot", plotOutput("oneMap", width = "800px", height = "800px"))
, tabPanel("Scatterplot", scatterD3Output("biScatter", width = "100%", height = "600px"))
, tabPanel("Two-Mean Plot", plotOutput("biMap", width = "800px", height = "800px")
, verbatimTextOutput("biMapText"))
)
, position="center"
, height= "auto"
)
)
)
#Definte server logic required to draw the map
server <- function(input, output, session) {
updateoneTable <- reactive({
onetable <- subset(newtable, newtable$MeanCode == tail(input$travelMeans, 1), select = -c(MeanCode)
, colnames = c('Territory', 'Mean Name', 'Number of People', 'Overall weight'))
onetable <- onetable[order(onetable$Percentage),]
rownames(onetable) <- seq(length=nrow(onetable))
return (onetable)
})
output$onetable <- DT::renderDataTable({
DT::datatable(
updateoneTable(), selection = "none"
, extensions = list("Scroller")
, options = list(
scrollY = 700
, pageLength = 30
, lengthMenu = list(c(30, -1), c("30", "All"))
)
)}
, server = TRUE
)
observe({
if (length(input$travelMeans) > maxGrp)
{
updateCheckboxGroupInput(session, 'travelMeans', selected = tail(input$travelMeans,maxGrp))
}
})
output$biMapText <- renderText({
paste("Red: ", meandata$MeanName[meandata$MeanCode == input$travelMeans[1]]
, "Purple: A combination of both travel means"
, "Blue: ", meandata$MeanName[meandata$MeanCode == input$travelMeans[2]], sep = "\n")
})
output$oneMap <- renderPlot(singleMap(input$categories, input$travelMeans, input$classIntMethod))
output$biMap  <- renderPlot(biMap(input$travelMeans))
biList <- reactive({
prepareTwoMeans(input$travelMeans)
})
output$biScatter <- renderScatterD3({
tooltips <- paste("<strong>Territory Authority: ", biList()$AreaName,"</strong><br /> Percentage of x: "
, biList()$Percentage.x, "<br />"
, "Percentage of y: ", biList()$Percentage.y)
plot <- scatterD3(x = biList()$Percentage.x, y = biList()$Percentage.y
, xlab = meandata$MeanName[meandata$MeanCode == unique(biList()$MeanCode.x)]
, ylab = meandata$MeanName[meandata$MeanCode == unique(biList()$MeanCode.y)]
, tooltip_text = tooltips
)
return (plot)
})
}
shinyApp(ui = ui, server = server)
